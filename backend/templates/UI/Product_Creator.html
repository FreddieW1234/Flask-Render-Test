<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Product Editor/Creator - Shopify Tools</title>
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='favicon.svg') }}">
    <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            padding: 10px;
            margin: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 18px 25px;
            margin-bottom: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left {
            display: flex;
            align-items: center;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .app-tabs {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 8px;
            width: 100%;
            max-width: 700px;
        }

        .app-tabs-row {
            display: contents;
        }

        .app-tab {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            text-decoration: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .app-tab:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateY(-1px);
        }

        .app-tab.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .app-tab i {
            font-size: 0.9rem;
        }

        .app-tab span {
            white-space: nowrap;
        }

        .dashboard-tab {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .dashboard-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 15px;
            white-space: nowrap;
        }


        .main-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .form-section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            user-select: none;
            transition: color 0.3s ease;
        }

        .section-title:hover {
            color: #667eea;
        }

        .section-title i {
            color: #667eea;
        }

        .dropdown-arrow {
            font-size: 14px;
            transition: transform 0.3s ease;
            margin-right: 8px;
        }

        .dropdown-arrow.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-section {
            margin-bottom: 30px;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
        }

        .section-header {
            background: #f7fafc;
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .section-content {
            padding: 20px;
            transition: all 0.3s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group.full-width {
            grid-column: 1 / -1;
        }

        .form-label {
            font-weight: 500;
            color: #4a5568;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-input, .form-textarea, .form-select {
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-textarea {
            min-height: 120px;
            resize: vertical;
        }

        .form-textarea[readonly] {
            background-color: #f7fafc;
            color: #4a5568;
            cursor: not-allowed;
            border-color: #e2e8f0;
        }

        .form-textarea[readonly]:focus {
            border-color: #e2e8f0;
            box-shadow: none;
        }

        .description-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        /* Currency input with ¬£ prefix (display-only) */
        /* Currency input: center-align with non-deletable ¬£ ghost character */
        .currency-input { position: relative; display: inline-flex; align-items: center; width: 100%; justify-content: center; }
        .currency-input input[type="number"] { text-align: center; }

        .convert-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .convert-btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .convert-btn i {
            font-size: 11px;
        }

        .radio-group {
            margin-top: 8px;
            display: flex;
            gap: 20px;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            color: #4a5568;
        }

        .radio-input {
            display: none;
        }

        .radio-custom {
            width: 18px;
            height: 18px;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            background: white;
            position: relative;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .radio-input:checked + .radio-custom {
            background: #667eea;
            border-color: #667eea;
        }

        .radio-input:checked + .radio-custom::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: white;
        }

        .radio-text {
            user-select: none;
        }

        /* Field Finder Styles */
        .field-finder-container {
            width: 100%;
        }

        .search-container {
            margin-bottom: 20px;
        }

        .autocomplete-container {
            position: relative;
        }

        .product-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        .product-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            max-height: 200px;
            overflow-y: auto;
        }

        .autocomplete-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f1f5f9;
        }

        .autocomplete-item:hover {
            background: #f8fafc;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .product-info {
            display: none;
        }

        .product-info.visible {
            display: block;
        }

        .metafields-section {
            margin-top: 20px;
        }

        .metafields-section .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 0;
            background: none;
            border: none;
        }

        .metafields-section .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #2d3748;
        }

        .section-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .settings-dropdown {
            position: relative;
        }

        .settings-btn {
            background: #e2e8f0;
            color: #4a5568;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .settings-btn:hover {
            background: #cbd5e0;
        }

        .settings-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            min-width: 150px;
            display: none;
        }

        .settings-menu.visible {
            display: block;
        }

        .settings-item {
            width: 100%;
            padding: 10px 15px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            font-size: 12px;
            color: #4a5568;
            transition: background 0.3s ease;
        }

        .settings-item:hover {
            background: #f8fafc;
        }

        .save-all-btn {
            background: #48bb78;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .save-all-btn:hover {
            background: #38a169;
        }

        .metafields-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .metafield-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            position: relative;
            gap: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .metafield-item:hover {
            border-color: #17a2b8;
            box-shadow: 0 4px 8px rgba(23, 162, 184, 0.1);
        }

        .metafield-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .metafield-name {
            font-weight: 600;
            color: #333;
            font-size: 1rem;
        }

        .metafield-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e9ecef;
        }
        
        .metafield-type {
            font-size: 0.7rem;
            color: #6c757d;
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .metafield-key {
            font-size: 0.7rem;
            color: #6c757d;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .metafield-value {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 0.9rem;
            resize: vertical;
            min-height: 60px;
        }

        .metafield-value:focus {
            outline: none;
            border-color: #17a2b8;
            box-shadow: 0 0 0 2px rgba(23, 162, 184, 0.1);
        }
        
        /* Custom dropdown styling */
        .custom-dropdown {
            position: relative;
            width: 100%;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .dropdown-button {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            background-color: #fff;
            cursor: pointer;
            min-height: 40px;
            transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }
        
        .dropdown-button:hover {
            border-color: #17a2b8;
        }
        
        .dropdown-button:focus {
            outline: none;
            border-color: #17a2b8;
            box-shadow: 0 0 0 2px rgba(23, 162, 184, 0.1);
        }
        
        .dropdown-text {
            flex: 1;
            text-align: left;
            color: #495057;
            font-size: 0.9rem;
        }
        
        .dropdown-arrow {
            color: #6c757d;
            font-size: 0.8rem;
            transition: transform 0.2s ease;
        }
        
        .dropdown-button.open .dropdown-arrow {
            transform: rotate(180deg);
        }
        
        .dropdown-content {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: #fff;
            border: 1px solid #ced4da;
            border-top: none;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .dropdown-option {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }
        
        .dropdown-option:hover {
            background-color: #f8f9fa;
        }
        
        .dropdown-option input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }
        
        .dropdown-option label {
            cursor: pointer;
            flex: 1;
            margin: 0;
            font-size: 0.9rem;
            color: #495057;
        }
        
        .dropdown-loading {
            padding: 12px;
            text-align: center;
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        .metafield-value.compact {
            width: 70% !important;
            min-height: 40px !important;
            max-width: 70% !important;
        }
        
        .metafield-input-row {
            display: flex !important;
            align-items: flex-start !important;
            gap: 10px !important;
            width: 100% !important;
        }

        .emoji-field-container {
            width: 50%;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .emoji-buttons {
            display: flex;
            gap: 5px;
            margin-top: 5px;
            justify-content: center;
            align-items: center;
        }

        .emoji-btn {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s ease;
            min-width: 50px;
            text-align: center;
        }

        .emoji-btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .emoji-btn.tick:hover {
            background: #d4edda;
            border-color: #c3e6cb;
        }

        .emoji-btn.cross:hover {
            background: #f8d7da;
            border-color: #f5c6cb;
        }

        .emoji-btn.selected {
            background: #A1A4AD;
            border-color: #495057;
            color: white;
            box-shadow: 0 2px 4px rgba(108, 117, 125, 0.3);
        }

        .list-dropdown {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
        }

        .list-dropdown:focus {
            outline: none;
            border-color: #17a2b8;
            box-shadow: 0 0 0 2px rgba(23, 162, 184, 0.1);
        }

        .loading-metafields {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 40px;
            color: #666;
            font-size: 14px;
        }

        .loading-metafields i {
            font-size: 16px;
            color: #667eea;
        }

        .no-metafields, .metafields-error {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 40px;
            color: #666;
            font-size: 14px;
        }

        .metafields-error {
            color: #e53e3e;
        }

        .no-metafields i, .metafields-error i {
            font-size: 16px;
        }

        .no-metafields i {
            color: #667eea;
        }

        .metafields-error i {
            color: #e53e3e;
        }



        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }

        .btn-success {
            background: #48bb78;
            color: white;
        }

        .btn-success:hover {
            background: #38a169;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading i {
            font-size: 24px;
            color: #667eea;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .result-message {
            margin-top: 20px;
            padding: 15px;
            border-radius: 12px;
            display: none;
        }

        .result-success {
            background: #f0fff4;
            border: 1px solid #9ae6b4;
            color: #22543d;
        }

        .result-error {
            background: #fed7d7;
            border: 1px solid #feb2b2;
            color: #742a2a;
        }

        .product-link {
            margin-top: 10px;
            padding: 10px;
            background: #e6fffa;
            border: 1px solid #81e6d9;
            border-radius: 8px;
        }

        .product-link a {
            color: #234e52;
            text-decoration: none;
            font-weight: 500;
        }

        .product-link a:hover {
            text-decoration: underline;
        }


        @media (max-width: 768px) {
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
        }

        /* Price Manager Styles */
        .price-manager-section {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }

        .price-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }

        .qty-autofill-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(102, 126, 234, 0.25);
        }

        .qty-autofill-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.35);
        }

        .qty-autofill-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.25);
        }

        .qty-autofill-button i {
            font-size: 1rem;
        }

        .qty-match-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            font-weight: 500;
            color: #333;
        }

        .qty-match-checkbox input[type="checkbox"] {
            display: none;
        }

        .checkmark {
            width: 20px;
            height: 20px;
            border: 2px solid #667eea;
            border-radius: 4px;
            background: white;
            position: relative;
            transition: all 0.2s ease;
        }

        .qty-match-checkbox input[type="checkbox"]:checked + .checkmark {
            background: #667eea;
            border-color: #667eea;
        }

        .qty-match-checkbox input[type="checkbox"]:checked + .checkmark::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        .metafield-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .metafield-box {
            flex: 1;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .metafield-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f8f9fa;
            justify-content: space-between;
        }

        .metafield-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #667eea;
        }

        .metafield-buttons {
            display: flex;
            gap: 10px;
        }

        .metafield-button {
            padding: 6px 12px;
            border: 2px solid #667eea;
            border-radius: 6px;
            background: white;
            color: #667eea;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .metafield-button.active {
            background: #667eea;
            color: white;
        }

        .metafield-button:hover {
            background: #667eea;
            color: white;
        }

        .metafield-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .metafield-table th {
            background-color: #2f405b;
            color: white;
            padding: 12px;
            border: 1px solid #ddd;
            font-weight: 600;
            text-align: center;
            font-size: 0.9rem;
        }

        .metafield-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
            background-color: white;
            font-size: 0.9rem;
        }

        .metafield-table tr:nth-child(even) td {
            background-color: #f8f9fa;
        }

        .metafield-table tr:hover td {
            background-color: #e8f5e8;
        }

        .metafield-table input {
            width: 100%;
            border: none;
            padding: 4px;
            text-align: center;
            background: transparent;
            font-size: 0.9rem;
        }

        .metafield-table input:focus {
            outline: none;
            background: #f0f8ff;
        }

        .add-row-button {
            margin-top: 10px;
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .add-row-button:hover {
            background: #5a6fd8;
        }

        /* Media Upload Styles */
        .media-upload-container {
            margin-top: 10px;
        }

        .media-upload-area {
            border: 2px dashed #667eea;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            background: rgba(102, 126, 234, 0.05);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .media-upload-area:hover {
            border-color: #5a6fd8;
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .media-upload-area.dragover {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.1);
        }

        .upload-icon {
            font-size: 48px;
            color: #667eea;
            margin-bottom: 16px;
        }

        .upload-text p {
            margin: 8px 0;
            color: #666;
        }

        .upload-text p:first-child {
            font-size: 16px;
            font-weight: 500;
            color: #333;
        }

        .upload-limit {
            font-size: 14px;
            color: #888;
        }

        /* Media Source Tabs */
        .media-source-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .media-tab {
            background: none;
            border: none;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .media-tab:hover {
            color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .media-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .media-tab-content {
            margin-top: 20px;
        }

        /* Shopify Media Selection */
        .shopify-media-container {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .shopify-media-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid #e0e0e0;
            background: white;
            border-radius: 8px 8px 0 0;
        }

        .media-search-box {
            position: relative;
            width: 300px;
        }

        .media-search-box input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .media-search-box i {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #999;
        }

        .shopify-media-grid {
            max-height: 400px;
            overflow-y: auto;
            padding: 16px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 16px;
        }

        .loading-placeholder {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .loading-placeholder i {
            font-size: 48px;
            margin-bottom: 16px;
            color: #ccc;
        }

        .shopify-media-item {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .shopify-media-item:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .shopify-media-item.selected {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.05);
        }

        .shopify-media-item img,
        .shopify-media-item video {
            width: 100%;
            height: 120px;
            object-fit: cover;
            display: block;
        }

        .shopify-media-info {
            padding: 8px;
            font-size: 12px;
        }

        .shopify-media-filename {
            font-weight: 500;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
        }

        .shopify-media-meta {
            color: #666;
            font-size: 11px;
        }

        .shopify-media-type {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
        }

        .media-preview-container {
            margin-top: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            background: white;
            overflow: hidden;
        }

        .media-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }

        .media-count {
            font-weight: 500;
            color: #333;
        }

        .clear-media-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .clear-media-btn:hover {
            background: #ff3742;
            transform: translateY(-1px);
        }

        .media-preview-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
            position: relative;
        }

        .media-preview-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .media-preview-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .media-preview-item img,
        .media-preview-item video {
            width: 100%;
            height: 120px;
            object-fit: cover;
            display: block;
        }

        .media-preview-item .media-info {
            padding: 8px;
            background: white;
        }

        .media-preview-item .media-name {
            font-size: 12px;
            font-weight: 500;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
        }

        .media-preview-item .media-size {
            font-size: 11px;
            color: #888;
        }

        .media-preview-item .remove-media {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(255, 71, 87, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .media-preview-item .remove-media:hover {
            background: #ff3742;
            transform: scale(1.1);
        }

        .media-preview-item .media-type {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
        }

        .media-preview-item .media-type.video {
            background: rgba(102, 126, 234, 0.9);
        }

        .media-preview-item .media-type.image {
            background: rgba(76, 175, 80, 0.9);
        }

        /* Drag and Drop Reordering Styles */
        .media-preview-item {
            cursor: move;
            user-select: none;
        }

        .media-preview-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
            z-index: 1000;
        }

        .media-preview-item.drag-over {
            border: 2px dashed #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .media-preview-item .drag-handle {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 10px;
            cursor: move;
            display: flex;
            align-items: center;
            gap: 2px;
            z-index: 10;
        }

        .media-preview-item .drag-handle:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        .media-preview-item .media-type {
            top: 30px;
        }

        .media-preview-item .remove-media {
            top: 4px;
            right: 4px;
        }

        .reorder-instructions {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .reorder-instructions i {
            color: #667eea;
        }

        /* Enhanced Drop Zone Styles */
        .drop-zone {
            width: 120px;
            height: 120px;
            border: 2px dashed #667eea;
            border-radius: 8px;
            background: rgba(102, 126, 234, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #667eea;
            font-size: 12px;
            font-weight: 500;
            text-align: center;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            position: relative;
        }

        .drop-zone.active {
            opacity: 1;
            background: rgba(102, 126, 234, 0.2);
            border-color: #4caf50;
            transform: scale(1.05);
        }

        .drop-zone::before {
            content: "Drop Here";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }

        .media-preview-item.drag-over {
            border: 2px solid #4caf50;
            background: rgba(76, 175, 80, 0.1);
            transform: scale(1.02);
        }

        .media-preview-item.dragging {
            opacity: 0.6;
            transform: rotate(3deg) scale(1.05);
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .media-preview-item.drag-placeholder {
            opacity: 0.3;
            border: 2px dashed #ccc;
            background: #f5f5f5;
        }

        .drag-indicator {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid #4caf50;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .drag-indicator.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1>
                    <i class="fas fa-plus-circle" style="color: #e91e63;"></i>
                    Product Editor/Creator
                </h1>
            </div>
            <div class="header-right">
                <div class="app-tabs">
                    <a href="/app/Artwork_Updater" class="app-tab">
                        <i class="fas fa-palette"></i>
                        <span>Artwork Updater</span>
                    </a>
                    <a href="/app/Field_Finder" class="app-tab">
                        <i class="fas fa-search"></i>
                        <span>Field Finder</span>
                    </a>
                    <a href="/app/price_bandit" class="app-tab">
                        <i class="fas fa-robot"></i>
                        <span>Price Bandit</span>
                    </a>
                    <a href="/app/Price_Manager" class="app-tab">
                        <i class="fas fa-chart-line"></i>
                        <span>Price Manager</span>
                    </a>
                    <a href="/app/Product_Creator" class="app-tab active">
                        <i class="fas fa-plus-circle"></i>
                        <span>Product Editor/Creator</span>
                    </a>
                    <a href="/app/Templates_Uploader" class="app-tab">
                        <i class="fas fa-file-archive"></i>
                        <span>Templates Uploader</span>
                    </a>
                </div>
                <a href="/" class="dashboard-tab">
                    <i class="fas fa-home"></i>
                    <span>Dashboard</span>
                </a>
            </div>
        </div>

        <div class="main-content">
            <form id="productForm">

                <!-- Import From Existing Product (Copied from Price Manager) -->
                <div class="tool-section" style="margin-bottom: 12px;">
                    <div class="search-container" style="display: flex; align-items: center; gap: 20px;">
                        <div class="autocomplete-container" style="width: 400px;">
                            <input type="text" id="pc-product-input" class="product-input" placeholder="Enter existing product name or SKU" style="width: 400px;">
                            <div id="pc-autocomplete-dropdown" class="autocomplete-dropdown" style="display: none;"></div>
                        </div>
                        <button type="button" class="btn btn-primary" onclick="showCreateForm()">
                            <i class="fas fa-plus-circle"></i> Create New Product
                        </button>
                    </div>
                </div>

                <!-- Basic Information Section -->
                <div class="collapsible-section" style="display: none;">
                    <div class="section-header" onclick="toggleSection('basicInfo')">
                    <h3 class="section-title">
                            <i class="fas fa-chevron-down dropdown-arrow" id="basicInfo-arrow"></i>
                        <i class="fas fa-info-circle"></i>
                        Basic Information
                    </h3>
                    </div>
                    <div class="section-content" id="basicInfo-content">
                    <div class="form-grid">
                        <div class="form-group full-width">
                            <label class="form-label">Product Title *</label>
                            <input type="text" id="title" name="title" class="form-input" placeholder="Enter product title" required>
                        </div>
                        <div class="form-group">
                                <div class="description-header">
                                    <label class="form-label">Tabs</label>
                                    <button type="button" id="convertBtn" class="convert-btn" onclick="toggleConverter()">
                                        <i class="fas fa-code"></i>
                                        <span id="convertText">Convert to HTML</span>
                                    </button>
                        </div>
                                <textarea id="description" name="description" class="form-textarea" placeholder="Enter product description" readonly>Product Info

Ingredients

Dietary</textarea>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Status</label>
                            <select id="status" name="status" class="form-select">
                                    <option value="active" selected>Active</option>
                                <option value="draft">Draft</option>
                                <option value="archived">Archived</option>
                            </select>
                        </div>
                        <div class="form-group">
                                <label class="form-label">Charge VAT</label>
                                <div class="radio-group">
                                    <label class="radio-label">
                                        <input type="radio" id="chargeVatYes" name="chargeVat" value="yes" class="radio-input" checked>
                                        <span class="radio-custom"></span>
                                        <span class="radio-text">Yes</span>
                                    </label>
                                    <label class="radio-label">
                                        <input type="radio" id="chargeVatNo" name="chargeVat" value="no" class="radio-input">
                                        <span class="radio-custom"></span>
                                        <span class="radio-text">No</span>
                                    </label>
                                </div>
                        </div>
                        <div class="form-group full-width">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                                <label class="form-label" style="margin: 0;">Colour Options</label>
                                <button type="button" id="fill-foil-colours-btn" style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; white-space: nowrap;">All foil colours</button>
                                <button type="button" id="reset-colours-btn" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; white-space: nowrap;">Reset</button>
                            </div>
                            <div id="colour-inputs-container" style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                                <div class="colour-cell" style="display: flex; width: calc(25% - 6px); border: 1px solid #ddd; border-radius: 4px; overflow: hidden;">
                                    <input type="text" class="colour-name-input form-input" placeholder="Colour" data-index="0" data-part="name" style="border: none; border-right: 1px solid #ddd; width: 55%; flex-shrink: 0;">
                                    <input type="text" class="colour-code-input form-input" placeholder="Code" data-index="0" data-part="code" style="border: none; border-right: 1px solid #ddd; width: 25%; flex-shrink: 0;">
                                    <button type="button" class="colour-image-btn" data-index="0" style="background: none; border: none; width: 20%; height: 100%; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; flex-shrink: 0; min-height: 30px;" title="Select image for this colour">üñºÔ∏è</button>
                                </div>
                                <div class="colour-cell" style="display: flex; width: calc(25% - 6px); border: 1px solid #ddd; border-radius: 4px; overflow: hidden;">
                                    <input type="text" class="colour-name-input form-input" placeholder="Colour" data-index="1" data-part="name" style="border: none; border-right: 1px solid #ddd; width: 55%; flex-shrink: 0;">
                                    <input type="text" class="colour-code-input form-input" placeholder="Code" data-index="1" data-part="code" style="border: none; border-right: 1px solid #ddd; width: 25%; flex-shrink: 0;">
                                    <button type="button" class="colour-image-btn" data-index="1" style="background: none; border: none; width: 20%; height: 100%; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; flex-shrink: 0; min-height: 30px;" title="Select image for this colour">üñºÔ∏è</button>
                                </div>
                                <button type="button" class="add-colour-btn" style="padding: 8px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">+</button>
                            </div>
                            <small style="color: #666; display: block; margin-top: 4px;">Enter colour name in left side, code in right side, the code will be added to the SKU. Click üñºÔ∏è to select an image for that colour, if no image is selected, the first image will be used.</small>
                        </div>
                        
                        </div>
                        
                        <!-- Media Upload Section -->
                        <div class="form-group full-width">
                            <label class="form-label">Product Media (Images/Videos)</label>
                            
                            <!-- Media Source Selection -->
                            <div class="media-source-tabs">
                                <button type="button" class="media-tab active" onclick="switchMediaTab('upload')" id="uploadTab">
                                    <i class="fas fa-cloud-upload-alt"></i> Upload New Files
                                </button>
                                <button type="button" class="media-tab" onclick="switchMediaTab('select')" id="selectTab">
                                    <i class="fas fa-folder-open"></i> Select from Shopify
                                </button>
                            </div>
                            
                            <!-- Upload Tab Content -->
                            <div class="media-tab-content" id="uploadTabContent">
                                <div class="media-upload-container">
                                    <div class="media-upload-area" id="mediaUploadArea">
                                        <div class="upload-icon">
                                            <i class="fas fa-cloud-upload-alt"></i>
                                        </div>
                                        <div class="upload-text">
                                            <p>Drag & drop images/videos here or click to browse</p>
                                            <p class="upload-limit">‚Ä¢ Maximum 250 files ‚Ä¢</p>
                                        </div>
                                        <input type="file" id="mediaFiles" name="mediaFiles" multiple accept="image/*,video/*" style="display: none;">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Select Tab Content -->
                            <div class="media-tab-content" id="selectTabContent" style="display: none;">
                                <div class="shopify-media-container">
                                    <div class="shopify-media-header">
                                        <div class="media-search-box">
                                            <input type="text" id="mediaSearchInput" placeholder="Search media files..." onkeyup="filterShopifyMedia()">
                                            <i class="fas fa-search"></i>
                                        </div>
                                    </div>
                                    <div class="shopify-media-grid" id="shopifyMediaGrid">
                                        
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Media Preview (shared for both tabs) -->
                            <div class="media-preview-container" id="mediaPreviewContainer" style="display: none;">
                                <div class="media-preview-header">
                                    <span class="media-count">0 files selected</span>
                                    <button type="button" class="clear-media-btn" onclick="clearAllMedia()">
                                        <i class="fas fa-trash"></i> Clear All
                                    </button>
                                </div>
                                <div class="reorder-instructions">
                                    <i class="fas fa-info-circle"></i>
                                    <span>Drag any media item by its grip handle to reorder. Drop it on another item to place it in that position. The order here will be the order on your Shopify product page.</span>
                                </div>
                                <div class="media-preview-grid" id="mediaPreviewGrid">
                                    <!-- Media previews will be added here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Field Editor Section -->
                <div class="collapsible-section" style="display: none;">
                    <div class="section-header" onclick="toggleSection('fieldEditor')">
                    <h3 class="section-title">
                            <i class="fas fa-chevron-down dropdown-arrow" id="fieldEditor-arrow"></i>
                            <i class="fas fa-edit"></i>
                            Field Editor
                    </h3>
                                </div>
                    <div class="section-content" id="fieldEditor-content">
                        <div class="field-finder-container">
                            <div class="metafields-section">
                                <div class="section-header">
                                    <div class="section-title">Metafields</div>
                                    <div class="section-controls"></div>
                                </div>
                                
                                <div class="metafields-grid" id="metafields-container">
                                    <div class="loading-metafields">
                                        <i class="fas fa-spinner fa-spin"></i>
                                        <span>Loading metafields...</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Pricing Section -->
                <div class="collapsible-section" style="display: none;">
                    <div class="section-header" onclick="toggleSection('pricing')">
                        <h3 class="section-title">
                            <i class="fas fa-chevron-down dropdown-arrow" id="pricing-arrow"></i>
                            <i class="fas fa-dollar-sign"></i>
                            Pricing
                        </h3>
                    </div>
                    <div class="section-content" id="pricing-content">
                        
                        <!-- Price Manager Integration -->
                        <div class="price-manager-section">
                            <h4 style="margin: 20px 0 15px 0; color: #667eea; font-size: 1.2rem;">Price Tiers</h4>
                            <div class="price-controls">
                                <button class="qty-autofill-button" type="button" onclick="autofillQuantities()">
                                    <i class="fas fa-magic"></i> Qty Autofill
                                </button>
                                <button class="qty-autofill-button" type="button" onclick="resetPricingTables()" style="background: #dc3545; margin-left: 8px;">
                                    <i class="fas fa-redo"></i> Reset
                                </button>
                                <label class="qty-match-checkbox">
                                    <input type="checkbox" id="qty-match-checkbox" checked>
                                    <span class="checkmark"></span>
                                    <span class="label-text">Match quantities and increase price by 30%</span>
                                </label>
                            </div>
                            
                            <div class="metafield-container">
                                <div class="metafield-box">
                                    <div class="metafield-header">
                                        <span class="metafield-title">Trade</span>
                                        <div class="metafield-buttons">
                                            <button class="metafield-button active" type="button">Table</button>
                                            <button class="metafield-button" type="button">JSON</button>
                                        </div>
                                    </div>
                                    <div class="metafield-content" id="trade-content">
                                        <table class="metafield-table">
                                            <thead>
                                                <tr>
                                                    <th>Min</th>
                                                    <th>Max</th>
                                                    <th>Price</th>
                                                </tr>
                                            </thead>
                                            <tbody id="trade-table-body">
                                                <tr>
                                                    <td><input type="number" data-index="0" data-field="min" placeholder="Min"></td>
                                                    <td><input type="number" data-index="0" data-field="max" placeholder="Max"></td>
                                                    <td>
                                                        <div class="currency-input">
                                                            <input type="text" inputmode="decimal" data-index="0" data-field="price" placeholder="¬£0.00">
                                                        </div>
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                        <button class="add-row-button" type="button">Add New Row</button>
                                    </div>
                                </div>
                                
                                <div class="metafield-box">
                                    <div class="metafield-header">
                                        <span class="metafield-title">End Customer</span>
                                        <div class="metafield-buttons">
                                            <button class="metafield-button active" type="button">Table</button>
                                            <button class="metafield-button" type="button">JSON</button>
                                        </div>
                                    </div>
                                    <div class="metafield-content" id="end-customer-content">
                                        <table class="metafield-table">
                                            <thead>
                                                <tr>
                                                    <th>Min</th>
                                                    <th>Max</th>
                                                    <th>Price</th>
                                                </tr>
                                            </thead>
                                            <tbody id="end-customer-table-body">
                                                <tr>
                                                    <td><input type="number" data-index="0" data-field="min" placeholder="Min"></td>
                                                    <td><input type="number" data-index="0" data-field="max" placeholder="Max"></td>
                                                    <td>
                                                        <div class="currency-input">
                                                            <input type="text" inputmode="decimal" data-index="0" data-field="price" placeholder="¬£0.00">
                                                        </div>
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                        <button class="add-row-button" type="button">Add New Row</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Artwork Section -->
                <div class="collapsible-section" style="display: none;">
                    <div class="section-header" onclick="toggleSection('artwork')">
                        <h3 class="section-title">
                            <i class="fas fa-chevron-down dropdown-arrow" id="artwork-arrow"></i>
                            <i class="fas fa-palette"></i>
                            Artwork
                        </h3>
                    </div>
                    <div class="section-content" id="artwork-content">
                        <div class="form-grid">
                            <div class="form-group full-width">
                                <label class="form-label">Guidelines</label>
                                <div class="form-grid">
                                    <div class="form-group">
                                        <div class="form-label">General:</div>
                                        <div id="artworkGuidelinesLeft" class="file-list" style="border:1px solid #eee;border-radius:8px;padding:10px;max-height:260px;overflow:auto;">
                                            <div class="muted">Loading‚Ä¶</div>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <div class="form-label">Advent:</div>
                                        <div id="artworkGuidelinesRight" class="file-list" style="border:1px solid #eee;border-radius:8px;padding:10px;max-height:260px;overflow:auto;">
                                            <div class="muted">Loading‚Ä¶</div>
                                        </div>
                                    </div>
                                </div>
                                
                            </div>

                            <div class="form-group full-width">
                                <label class="form-label">Templates</label>
                                <div class="media-upload-container">
                                    <div class="media-upload-area" id="artworkTemplatesUploadArea">
                                        <div class="upload-icon">
                                            <i class="fas fa-cloud-upload-alt"></i>
                                        </div>
                                        <div class="upload-text">
                                            <p>Drag & drop files here or click to browse</p>
                                            <p class="upload-limit">‚Ä¢ Multiple files allowed ‚Ä¢</p>
                                        </div>
                                        <input type="file" id="artworkTemplatesInput" multiple style="display:none;">
                                    </div>
                                </div>
                                <div id="artworkTemplatesList" style="margin-top:10px;"></div>
                                <div id="pcVersionsPanel" class="mf" style="margin-top:12px; display:none;"></div>
                                
                            </div>
                        </div>
                    </div>
                </div>


                <!-- Action Buttons -->
                <div class="action-buttons" style="display: none;">
                    <button type="button" class="btn btn-secondary" onclick="resetForm()">
                        <i class="fas fa-undo"></i>
                        Reset Form
                    </button>
                    <button type="submit" class="btn btn-success">
                        <i class="fas fa-plus-circle"></i>
                        Create Product
                    </button>
                </div>
            </form>

            <!-- Loading Indicator -->
            <div class="loading" id="loading">
                <i class="fas fa-spinner"></i>
                <p>Creating product...</p>
            </div>

            <!-- Result Message -->
            <div class="result-message" id="resultMessage"></div>
        </div>
    </div>

    <script>
        let isHtmlMode = false;

        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId + '-content');
            const arrow = document.getElementById(sectionId + '-arrow');

            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                arrow.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                arrow.classList.add('collapsed');
            }
        }

        function showCreateForm() {
            // Show all hidden form sections
            const sections = document.querySelectorAll('.collapsible-section[style*="display: none"], .action-buttons[style*="display: none"]');
            sections.forEach(section => {
                section.style.display = 'block';
            });

            // Hide only the Create New Product button, keep search bar visible
            const createBtn = document.querySelector('button[onclick="showCreateForm()"]');
            if (createBtn) {
                createBtn.style.display = 'none';
            }
        }

        // Artwork: load guidelines and enable templates staging
        let artworkGuidelinesLeft = [];
        let artworkGuidelinesRight = [];
        let stagedArtworkTemplateFiles = [];
        let pcStagedRemoteEntries = [];
        let pcCurrentTemplatesFileGlobalId = '';

        // Track if we're editing an existing product
        let selectedProduct = null;
        let isEditingProduct = false;

        document.addEventListener('DOMContentLoaded', async function () {
            try {
                const resp = await fetch('/api/shopify/files');
                const files = await resp.json();
                renderGuidelinesColumns(files || []);
            } catch (e) {
                document.getElementById('artworkGuidelinesLeft').innerHTML = '<div class="danger">Failed to load files</div>';
                document.getElementById('artworkGuidelinesRight').innerHTML = '<div class="danger">Failed to load files</div>';
            }

            // Templates upload box wiring
            const area = document.getElementById('artworkTemplatesUploadArea');
            const input = document.getElementById('artworkTemplatesInput');
            area.addEventListener('click', () => input.click());
            area.addEventListener('dragover', e => { e.preventDefault(); area.classList.add('dragover'); });
            area.addEventListener('dragleave', () => area.classList.remove('dragover'));
            area.addEventListener('drop', e => {
                e.preventDefault();
                area.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                stageArtworkTemplates(files);
            });
            input.addEventListener('change', e => {
                const files = Array.from(e.target.files);
                stageArtworkTemplates(files);
            });

            // Versions panel will only show when a product is selected
        });

        function renderGuidelinesColumns(files) {
            artworkGuidelinesLeft = [];
            artworkGuidelinesRight = [];
            try {
                files.forEach(f => {
                    const name = (f.filename || f.alt || '').toLowerCase();
                    if (name.includes('artwork_guidelines_a')) {
                        artworkGuidelinesRight.push(f);
                    } else if (name.includes('artwork_guidelines')) {
                        artworkGuidelinesLeft.push(f);
                    }
                });
            } catch {}
            const leftEl = document.getElementById('artworkGuidelinesLeft');
            const rightEl = document.getElementById('artworkGuidelinesRight');
            leftEl.innerHTML = buildGuidelinesListHtml(artworkGuidelinesLeft, 'left');
            rightEl.innerHTML = buildGuidelinesListHtml(artworkGuidelinesRight, 'right');
        }

        function buildGuidelinesListHtml(arr, col) {
            if (!arr || arr.length === 0) return '<div class="muted">No files found</div>';
            const items = arr
                .slice()
                .sort((a,b) => new Date(b.created_at||0) - new Date(a.created_at||0))
                .map(f => {
                    const name = f.filename || f.alt || 'untitled';
                    const gid = f.original_global_id || '';
                    return `<div class=\"guideline-row\" data-gid=\"${encodeURIComponent(gid)}\" data-col=\"${col}\" style=\"display:flex;align-items:center;gap:10px;padding:6px 8px;border:1px solid #eee;border-radius:6px;margin:4px 0;\">\n                        <div class=\"guideline-name\" style=\"flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;\">${name}</div>\n                        <button type=\"button\" class=\"btn btn-secondary use-btn\" onclick=\"selectGuideline('${encodeURIComponent(name)}','${col}','${encodeURIComponent(gid)}', this)\">Use</button>\n                    </div>`;
                }).join('');
            return items;
        }

        let selectedGuideline = null; // { id, name, column }
        function selectGuideline(nameEnc, column, idEnc, buttonEl) {
            const name = decodeURIComponent(nameEnc);
            const gid = idEnc ? decodeURIComponent(idEnc) : '';
            selectedGuideline = { id: gid, name, column };
            // Visual feedback: toggle buttons to reflect single selection
            document.querySelectorAll('.guideline-row .use-btn').forEach(btn => {
                btn.classList.remove('btn-success');
                btn.classList.add('btn-secondary');
                btn.textContent = 'Use';
            });
            if (buttonEl) {
                buttonEl.classList.remove('btn-secondary');
                buttonEl.classList.add('btn-success');
                buttonEl.textContent = 'Selected';
            }
        }

        function stageArtworkTemplates(files) {
            const list = document.getElementById('artworkTemplatesList');
            (files || []).forEach(f => stagedArtworkTemplateFiles.push(f));
            const remoteItems = (pcStagedRemoteEntries || []).map(e => ({
                name: e.name,
                size: e.size || 0,
                is_image: !!e.is_image,
                _type: 'remote'
            }));
            const localItems = (stagedArtworkTemplateFiles || []).map((f, i) => ({
                name: f.name,
                size: f.size || 0,
                is_image: f.type && f.type.startsWith('image/'),
                preview: URL.createObjectURL(f),
                _type: 'local',
                _index: i
            }));
            const items = remoteItems.concat(localItems);
            if (!items.length) {
                list.innerHTML = '<div class="muted"></div>';
                return;
            }
            list.innerHTML = '<div style="font-weight:600;margin-bottom:8px;">Current contents</div>' + items.map(it => {
                const viewUrl = it._type === 'remote'
                    ? `/api/templates-uploader/zip-file?file_global_id=${encodeURIComponent(pcCurrentTemplatesFileGlobalId)}&name=${encodeURIComponent(it.name)}`
                    : it.preview;
                const removeBtn = it._type === 'remote'
                    ? `<button type=\"button\" title=\"Remove\" onclick=\"removePcTemplate('${it.name.replace(/'/g, "\\'")}', 'remote')\" style=\"border:none;background:none;color:#e53935;cursor:pointer;\"><i class=\"fas fa-times\"></i></button>`
                    : `<button type=\"button\" title=\"Remove\" onclick=\"removePcTemplate(${it._index}, 'local')\" style=\"border:none;background:none;color:#e53935;cursor:pointer;\"><i class=\"fas fa-times\"></i></button>`;
                return `<div style=\"display:flex;align-items:center;gap:10px;margin:4px 0;\">\n                    <div style=\"width:40px;height:40px;border:1px dashed #ccc;border-radius:6px;display:flex;align-items:center;justify-content:center;color:#999;\"><i class=\"fas fa-file\"></i></div>\n                    <div style=\"flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;\">${it.name}</div>\n                    <a href=\"${viewUrl}\" target=\"_blank\" rel=\"noopener\" title=\"Open\" style=\"color:#667eea;\"><i class=\"fas fa-eye\"></i></a>\n                    ${removeBtn}\n                </div>`;
            }).join('');
            // Render versions panel header like Templates Uploader
            renderPcVersionsHeader();
        }

        function removePcTemplate(arg, type) {
            if (type === 'local') {
                const idx = Number(arg);
                if (!Number.isNaN(idx)) {
                    stagedArtworkTemplateFiles.splice(idx, 1);
                }
            } else if (type === 'remote') {
                pcStagedRemoteEntries = pcStagedRemoteEntries.filter(e => e.name !== arg);
            }
            stageArtworkTemplates([]);
        }

        // Sanitize name base on client (moved to global scope)
        function sanitizeBase(s) {
            let base = (s || '').trim().replace(/\r|\n/g, ' ');
            const forbidden = /[<>:"/\\|?*]/g;
            base = base.replace(forbidden, '');
            base = base.split(/\s+/).filter(Boolean).join('_');
            return base;
        }

        async function uploadArtworkTemplatesAfterCreate(productId, productTitle) {
            // Resolve SKU to follow naming pattern {SKU}_{product name}_artwork_templates
            let sku = '';
            try {
                const pr = await fetch(`/api/product/${productId}/prices`);
                const pdata = await pr.json();
                // Try metafield custom.sku if present
                const mfs = pdata.metafields || [];
                const mfSku = (mfs.find(m => (m.namespace === 'custom' && m.key === 'sku')) || {}).value;
                if (mfSku) sku = mfSku;
                // Fallback to first variant SKU
                if (!sku && pdata.variants && pdata.variants.length) {
                    sku = pdata.variants[0].sku || '';
                }
            } catch {}
            if (!sku) sku = 'NOSKU';

            const baseName = `${sanitizeBase(sku)}_${sanitizeBase(productTitle)}_artwork_templates`;

            const fd = new FormData();
            fd.append('product_id', String(productId));
            fd.append('zip_name', baseName);
            stagedArtworkTemplateFiles.forEach(f => fd.append('files', f, f.name));

            const resp = await fetch('/api/templates-uploader/upload-zip', { method: 'POST', body: fd });
            const data = await resp.json();
            if (!data || !data.success) {
                throw (data && data.error) || 'Upload failed';
            }
            return true;
        }

        function resetForm() {
            // Simply refresh the entire page
            window.location.reload();
        }

        function getVatTag() {
            const chargeVatYes = document.getElementById('chargeVatYes').checked;
            return chargeVatYes ? 'VAT-able products' : 'Non-VAT-able products';
        }

        // Field Finder functionality
        let metafields = [];

        function toggleSettingsDropdown() {
            const menu = document.getElementById('settings-menu');
            menu.classList.toggle('visible');
        }

        function openMovePanesModal() {
            // Placeholder for move panes functionality
            alert('Move Panes functionality would be implemented here');
        }

        // Collect all metafield data from the form
        function collectMetafieldsData() {
            const metafieldsData = [];
            const metafieldItems = document.querySelectorAll('.metafield-item');
            
            metafieldItems.forEach(item => {
                // Special handling for product_size field with 3 separate inputs
                const productSizeFields = item.querySelectorAll('.product-size-field');
                if (productSizeFields.length > 0) {
                    // This is a product_size field with 3 separate inputs
                    const lengthField = Array.from(productSizeFields).find(f => f.dataset.part === 'length');
                    const widthField = Array.from(productSizeFields).find(f => f.dataset.part === 'width');
                    const heightField = Array.from(productSizeFields).find(f => f.dataset.part === 'height');
                    
                    const length = lengthField ? lengthField.value.trim() : '';
                    const width = widthField ? widthField.value.trim() : '';
                    const height = heightField ? heightField.value.trim() : '';
                    
                    // Concatenate with '*' only if at least one field has a value
                    if (length || width || height) {
                        const key = lengthField ? lengthField.dataset.key : 'product_size';
                        const namespace = lengthField ? lengthField.dataset.namespace : 'custom';
                        const type = lengthField ? lengthField.dataset.type : 'single_line_text_field';
                        metafieldsData.push({
                            namespace: namespace,
                            key: key,
                            type: type,
                            value: `${length}*${width}*${height}`
                        });
                    }
                } else {
                    // Check for emoji field container first
                    const emojiContainer = item.querySelector('.emoji-field-container');
                    if (emojiContainer) {
                        const namespace = emojiContainer.dataset.namespace;
                        const key = emojiContainer.dataset.key;
                        const metafieldType = emojiContainer.dataset.type;
                        const value = emojiContainer.dataset.selectedValue || '';
                        
                        // Only include metafields that have values
                        if (value) {
                            metafieldsData.push({
                                namespace: namespace,
                                key: key,
                                type: metafieldType,
                                value: value
                        });
                    }
                } else {
                    // Check for custom dropdown first (category/subcategory), then other input types
                    let inputElement = item.querySelector('.custom-dropdown');
                    if (!inputElement) {
                        inputElement = item.querySelector('textarea.metafield-value, select.metafield-value.list-dropdown, input.metafield-value:not(.product-size-field)');
                    }
                    
                    if (inputElement) {
                        const namespace = inputElement.dataset.namespace;
                        const key = inputElement.dataset.key;
                        const metafieldType = inputElement.dataset.type;
                        
                        // Handle custom dropdowns for category and subcategory
                        let value;
                        if (key === 'custom_category' || key === 'subcategory') {
                            // Get all checked checkboxes from custom dropdown
                            const checkedBoxes = inputElement.querySelectorAll('input[type="checkbox"]:checked');
                            console.log(`üîç Found ${checkedBoxes.length} checked checkboxes for ${key}`);
                            // Normalize values: trim whitespace and ensure exact match with available options
                            value = Array.from(checkedBoxes).map(checkbox => {
                                const val = checkbox.value.trim();
                                console.log(`üìã Checking checkbox value for ${key}: "${val}"`);
                                return val;
                            }).filter(v => v !== '');
                            console.log(`üì¶ Collected ${key} values:`, value);
                            console.log(`üì¶ Full dropdown element for ${key}:`, inputElement);
                            console.log(`üì¶ Namespace: ${namespace}, Key: ${key}, Type: ${metafieldType}`);
                            
                            // Validate that all values exist in available choices
                            if (value.length > 0) {
                                const allCheckboxes = inputElement.querySelectorAll('input[type="checkbox"]');
                                const availableValues = new Set(Array.from(allCheckboxes).map(cb => cb.value.trim()));
                                const invalidValues = value.filter(v => !availableValues.has(v));
                                if (invalidValues.length > 0) {
                                    console.warn(`‚ö†Ô∏è Invalid ${key} values found (not in available choices):`, invalidValues);
                                    console.warn(`‚ö†Ô∏è Available ${key} choices:`, Array.from(availableValues));
                                    // Remove invalid values to prevent 422 errors
                                    value = value.filter(v => availableValues.has(v));
                                    console.log(`üì¶ Filtered ${key} values after validation:`, value);
                                }
                            }
                        } else {
                            value = inputElement.value.trim();
                        }
                        
                        // Only include metafields that have values
                        if (value && (Array.isArray(value) ? value.length > 0 : value)) {
                            // Force list type for category and subcategory to mirror Field Finder
                            const forcedType = (key === 'custom_category' || key === 'subcategory') ? 'list.single_line_text_field' : metafieldType;
                            
                            // For list types with array values, stringify the array
                            let finalValue = value;
                            if (Array.isArray(value) && forcedType === 'list.single_line_text_field') {
                                finalValue = JSON.stringify(value);
                                console.log(`üìù Stringified ${key} value:`, finalValue);
                            }
                            
                            metafieldsData.push({
                                namespace: namespace,
                                key: key,
                                type: forcedType,
                                value: finalValue
                            });
                            console.log(`‚úÖ Added ${key} to metafieldsData:`, { namespace, key, type: forcedType, value: finalValue });
                        }
                        }
                    }
                }
            });
            
            console.log('Collected metafields data:', metafieldsData);
            return metafieldsData;
        }

        // Price Manager functionality
        let currentPriceData = { trade: [], endCustomer: [] };
        let pricingQtyBands = [];

        // Fetch pricing quantity bands from backend
        async function fetchPricingQtyBands() {
            try {
                const response = await fetch('/api/pricing-qty-bands');
                const data = await response.json();
                if (data.success) {
                    pricingQtyBands = data.bands;
                    console.log('üìä Pricing quantity bands loaded:', pricingQtyBands);
                } else {
                    console.error('Failed to load pricing quantity bands:', data.error);
                    // Fallback to default bands if API fails
                    pricingQtyBands = [[100, 250], [300, 500], [550, 1000], [1050, 2500], [2550, 5000], [5050, 10000]];
                }
            } catch (error) {
                console.error('Error fetching pricing quantity bands:', error);
                // Fallback to default bands
                pricingQtyBands = [[100, 250], [300, 500], [550, 1000], [1050, 2500], [2550, 5000], [5050, 10000]];
            }
        }

        // Autofill quantities for both pricing tables
        function autofillQuantities() {
            if (pricingQtyBands.length === 0) {
                alert('Quantity bands not loaded yet. Please try again.');
                return;
            }

            // Get both table bodies
            const tradeTableBody = document.getElementById('trade-table-body');
            const endCustomerTableBody = document.getElementById('end-customer-table-body');

            if (!tradeTableBody || !endCustomerTableBody) {
                alert('Pricing tables not found.');
                return;
            }

            // Function to autofill a single table
            function autofillTable(tableBody) {
                // Clear existing rows
                tableBody.innerHTML = '';

                // Add rows based on quantity bands
                pricingQtyBands.forEach((band, index) => {
                    const [min, max] = band;
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td><input type="number" data-index="${index}" data-field="min" value="${min}"></td>
                        <td><input type="number" data-index="${index}" data-field="max" value="${max}"></td>
                        <td>
                            <div class="currency-input">
                                <input type="text" inputmode="decimal" data-index="${index}" data-field="price" placeholder="¬£0.00">
                            </div>
                        </td>
                    `;
                    
                    tableBody.appendChild(row);
                });

                // Set up event listeners for the new inputs
                tableBody.querySelectorAll('input').forEach(input => {
                    input.addEventListener('keydown', handleInputKeydown);
                    input.addEventListener('input', handleInputChange);
                    if (input.dataset.field === 'price') {
                        input.addEventListener('focus', handlePriceFocus);
                        input.addEventListener('blur', handlePriceBlur);
                        input.addEventListener('keydown', handlePriceKeydown);
                        input.addEventListener('keyup', () => enforcePriceCaretBounds(input));
                        input.addEventListener('click', () => enforcePriceCaretBounds(input));
                    }
                });

                // Update JSON data
                const contentId = tableBody.closest('.metafield-content').id;
                updateJSONFromTable(contentId);
                setupFirstRowPlaceholderHandlers(contentId);
            }

            // Autofill both tables
            autofillTable(tradeTableBody);
            autofillTable(endCustomerTableBody);

            console.log('‚úÖ Quantity bands autofilled successfully');
        }

        // Reset pricing tables to empty state
        function resetPricingTables() {
            // Clear the pricing data
            currentPriceData.trade = [];
            currentPriceData.endCustomer = [];

            // Rebuild both tables (which will show one empty row each)
            rebuildTable('trade-content', 'trade-table-body');
            rebuildTable('end-customer-content', 'end-customer-table-body');

            console.log('‚úÖ Pricing tables reset to empty state');
        }

        // Initialize price manager
        function initializePriceManager() {
            // Set up event listeners for price manager buttons
            document.querySelectorAll('.metafield-button').forEach(button => {
                button.addEventListener('click', function() {
                    const metafieldBox = this.closest('.metafield-box');
                    const contentId = metafieldBox.querySelector('.metafield-content').id;
                    const tableBodyId = contentId === 'trade-content' ? 'trade-table-body' : 'end-customer-table-body';
                    
                    if (this.textContent.trim() === 'Table') {
                        // Rebuild table view reliably
                        rebuildTable(contentId, tableBodyId);
                        showEditableTable(contentId);
                    } else if (this.textContent.trim() === 'JSON') {
                        showRawJSON(contentId);
                    }
                });
            });

            // Set up event listeners for add row buttons using event delegation
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('add-row-button')) {
                    const button = e.target;
                    const metafieldContent = button.closest('.metafield-content');
                    if (!metafieldContent) return;
                    let tableBody = metafieldContent.querySelector('tbody');
                    // If table structure not present (e.g., after JSON view), rebuild it first
                    if (!tableBody) {
                        const contentId = metafieldContent.id;
                        const tableBodyId = contentId === 'trade-content' ? 'trade-table-body' : 'end-customer-table-body';
                        rebuildTable(contentId, tableBodyId);
                        tableBody = metafieldContent.querySelector('tbody');
                    }
                    if (tableBody) addNewRow(tableBody.id);
                }
            });

            // Set up event listeners for table inputs
            document.querySelectorAll('.metafield-table input').forEach(input => {
                input.addEventListener('keydown', handleInputKeydown);
                input.addEventListener('input', handleInputChange);
                if (input.dataset.field === 'price') {
                    input.addEventListener('focus', handlePriceFocus);
                    input.addEventListener('blur', handlePriceBlur);
                    input.addEventListener('keydown', handlePriceKeydown);
                    input.addEventListener('keyup', () => enforcePriceCaretBounds(input));
                    input.addEventListener('click', () => enforcePriceCaretBounds(input));
                }
            });

            // Set up combined checkbox event listener
            document.getElementById('qty-match-checkbox').addEventListener('change', function() {
                if (this.checked) {
                    syncQuantityRanges();
                    syncPricesFromTrade();
                }
                // lock/unlock right table
                updateEndCustomerEditability();
            });

            // Initialize with default data
            initializeDefaultPriceData();
            // Apply initial lock state to right table on page load
            updateEndCustomerEditability();
            // Setup placeholder handlers for both tables
            setupFirstRowPlaceholderHandlers('trade-content');
            setupFirstRowPlaceholderHandlers('end-customer-content');
        }

        function initializeDefaultPriceData() {
            // Initialize with empty arrays - no default pricing data
            currentPriceData.trade = [];
            currentPriceData.endCustomer = [];
        }

        // Toggle end-customer editability and add-row visibility based on combined checkbox
        function updateEndCustomerEditability() {
            const isLocked = !!document.getElementById('qty-match-checkbox')?.checked;
            const endContent = document.getElementById('end-customer-content');
            if (!endContent) return;
            const addBtn = endContent.querySelector('.add-row-button');
            if (addBtn) addBtn.style.display = isLocked ? 'none' : '';
            const inputs = endContent.querySelectorAll('input');
            inputs.forEach(inp => {
                if (isLocked) {
                    inp.setAttribute('readonly', 'readonly');
                } else {
                    inp.removeAttribute('readonly');
                }
            });
        }

        // Ensure first row placeholders hide on focus in first row and reappear when leaving table if still empty
        function setupFirstRowPlaceholderHandlers(contentId) {
            const content = document.getElementById(contentId);
            if (!content) return;
            const table = content.querySelector('.metafield-table');
            if (!table) return;
            if (table.dataset.placeholderHandlersAttached === 'true') return;
            table.dataset.placeholderHandlersAttached = 'true';

            const otherId = contentId === 'trade-content' ? 'end-customer-content' : 'trade-content';
            function getOtherTable() {
                const otherContent = document.getElementById(otherId);
                return otherContent ? otherContent.querySelector('.metafield-table') : null;
            }

            function getDefaultPlaceholder(input) {
                const field = input?.dataset?.field;
                if (field === 'min') return 'Min';
                if (field === 'max') return 'Max';
                if (field === 'price') return '¬£0.00';
                return '';
            }

            function restorePlaceholdersIfEmpty() {
                const firstRow = table.querySelector('tbody tr');
                if (!firstRow) return;
                const inputs = firstRow.querySelectorAll('input');
                const anyFocusedInTable = table.contains(document.activeElement);
                if (anyFocusedInTable) return;
                let allEmpty = true;
                inputs.forEach(inp => { if ((inp.value || '').trim() !== '') allEmpty = false; });
                if (allEmpty) {
                    inputs.forEach(inp => { inp.placeholder = getDefaultPlaceholder(inp); });
                }
            }

            table.addEventListener('focusin', function(e) {
                const firstRow = table.querySelector('tbody tr');
                if (!firstRow) return;
                if (firstRow.contains(e.target)) {
                    firstRow.querySelectorAll('input').forEach(inp => { inp.placeholder = ''; });
                    // Mirror: also clear placeholders in the other table's first row
                    const otherTable = getOtherTable();
                    if (otherTable) {
                        const otherFirst = otherTable.querySelector('tbody tr');
                        if (otherFirst) otherFirst.querySelectorAll('input').forEach(inp => { inp.placeholder = ''; });
                    }
                }
            });
            table.addEventListener('focusout', function() {
                setTimeout(() => {
                    const active = document.activeElement;
                    const otherTable = getOtherTable();
                    const inThis = table.contains(active);
                    const inOther = otherTable ? otherTable.contains(active) : false;
                    if (!inThis && !inOther) {
                        // Restore placeholders for both tables if their first rows are empty
                        restorePlaceholdersIfEmpty();
                        if (otherTable) {
                            const saveTable = table; // temporarily swap to reuse helper
                            // Temporarily bind helper to other table context
                            (function restoreOther() {
                                const firstRow = otherTable.querySelector('tbody tr');
                                if (!firstRow) return;
                                const inputs = firstRow.querySelectorAll('input');
                                let allEmpty = true;
                                inputs.forEach(inp => { if ((inp.value || '').trim() !== '') allEmpty = false; });
                                if (allEmpty) {
                                    inputs.forEach(inp => { inp.placeholder = getDefaultPlaceholder(inp); });
                                }
                            })();
                        }
                    }
                }, 0);
            });
        }

        function showEditableTable(contentId) {
            const content = document.getElementById(contentId);
            const tableElement = content.querySelector('.metafield-table');
            
            if (tableElement) {
                tableElement.style.display = 'table';
            }
            
            // Update button states
            const buttons = content.parentNode.querySelectorAll('.metafield-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            const tableButton = Array.from(buttons).find(btn => btn.textContent.trim() === 'Table');
            if (tableButton) {
                tableButton.classList.add('active');
            }
        }

        function showRawJSON(contentId) {
            const content = document.getElementById(contentId);
            const tableElement = content.querySelector('.metafield-table');
            
            if (tableElement) {
                tableElement.style.display = 'none';
            }
            
            // Get current data based on content ID
            let metafieldData = [];
            if (contentId === 'trade-content') {
                metafieldData = currentPriceData.trade || [];
            } else if (contentId === 'end-customer-content') {
                metafieldData = currentPriceData.endCustomer || [];
            }
            
            // Display raw JSON with custom formatting for prices to show 2 decimal places
            const jsonStr = JSON.stringify(metafieldData, null, 2);
            // Replace price values to show 2 decimal places (handles both "price": 2 and "price": "2.00")
            const formattedJson = jsonStr.replace(/("price":\s*)(["'])?(-?\d+\.?\d*)(["'])?/g, (match, label, quoteBefore, price, quoteAfter) => {
                const num = parseFloat(price);
                if (!isNaN(num)) {
                    const formatted = num.toFixed(2);
                    return label + (quoteBefore || '') + formatted + (quoteAfter || quoteBefore || '');
                }
                return match;
            });
            
            content.innerHTML = `<div style="font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-size: 0.9rem; line-height: 1.5; color: #333; padding: 12px; background-color: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); white-space: normal; word-wrap: break-word; max-width: 100%; overflow-wrap: break-word;">${formattedJson}</div>`;
            
            // Update button states
            const buttons = content.parentNode.querySelectorAll('.metafield-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            const jsonButton = Array.from(buttons).find(btn => btn.textContent.trim() === 'JSON');
            if (jsonButton) {
                jsonButton.classList.add('active');
            }
        }

        // Rebuild table markup from current data (to fix toggle bug)
        function rebuildTable(contentId, tableBodyId) {
            const content = document.getElementById(contentId);
            content.innerHTML = `
                <table class="metafield-table">
                    <thead>
                        <tr>
                            <th>Min</th>
                            <th>Max</th>
                            <th>Price</th>
                        </tr>
                    </thead>
                    <tbody id="${tableBodyId}"></tbody>
                </table>
                <button class="add-row-button" type="button">Add New Row</button>
            `;
            // Repopulate rows from synchronized data
            const data = contentId === 'trade-content' ? (currentPriceData.trade || []) : (currentPriceData.endCustomer || []);
            const tbody = document.getElementById(tableBodyId);
            
            // Always create at least one row with placeholders if no data exists
            if (data.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><input type="number" value="" data-index="0" data-field="min" placeholder="Min"></td>
                    <td><input type="number" value="" data-index="0" data-field="max" placeholder="Max"></td>
                    <td><div class="currency-input"><input type="text" inputmode="decimal" value="" data-index="0" data-field="price" placeholder="¬£0.00"></div></td>
                `;
                tbody.appendChild(row);
                
                // Attach listeners for the placeholder row
                const inputs = row.querySelectorAll('input');
                inputs.forEach(input => {
                    input.addEventListener('keydown', handleInputKeydown);
                    input.addEventListener('input', handleInputChange);
                    if (input.dataset.field === 'price') {
                        input.addEventListener('focus', handlePriceFocus);
                        input.addEventListener('blur', handlePriceBlur);
                        input.addEventListener('keydown', handlePriceKeydown);
                        input.addEventListener('keyup', () => enforcePriceCaretBounds(input));
                        input.addEventListener('click', () => enforcePriceCaretBounds(input));
                    }
                });
            } else {
                // Create rows from existing data
            data.forEach((item, index) => {
                const row = document.createElement('tr');
                const priceValue = typeof item.price === 'number' ? item.price.toFixed(2) : (item.price || '');
                row.innerHTML = `
                    <td><input type="number" value="${item.min ?? ''}" data-index="${index}" data-field="min"></td>
                    <td><input type="number" value="${item.max ?? ''}" data-index="${index}" data-field="max"></td>
                    <td><div class="currency-input"><input type="text" inputmode="decimal" value="${priceValue ? ('¬£' + priceValue) : ''}" data-index="${index}" data-field="price" placeholder=""></div></td>
                `;
                tbody.appendChild(row);
                // Attach listeners for rebuilt rows
                const inputs = row.querySelectorAll('input');
                inputs.forEach(input => {
                    input.addEventListener('keydown', handleInputKeydown);
                    input.addEventListener('input', handleInputChange);
                    if (input.dataset.field === 'price') {
                        input.addEventListener('focus', handlePriceFocus);
                        input.addEventListener('blur', handlePriceBlur);
                        input.addEventListener('keydown', handlePriceKeydown);
                        input.addEventListener('keyup', () => enforcePriceCaretBounds(input));
                        input.addEventListener('click', () => enforcePriceCaretBounds(input));
                    }
                });
                // Don't format on creation - let handlePriceBlur do it
            });
            }
            setupFirstRowPlaceholderHandlers(contentId);
            if (contentId === 'end-customer-content') {
                updateEndCustomerEditability();
            }
        }

        function addNewRow(tableBodyId) {
            const tableBody = document.getElementById(tableBodyId);
            if (tableBody) {
                const newRow = document.createElement('tr');
                newRow.innerHTML = `
                    <td><input type="number" value="" data-index="${tableBody.children.length}" data-field="min" placeholder=""></td>
                    <td><input type="number" value="" data-index="${tableBody.children.length}" data-field="max" placeholder=""></td>
                    <td><div class="currency-input"><input type="text" inputmode="decimal" value="" data-index="${tableBody.children.length}" data-field="price" placeholder=""></div></td>
                `;
                tableBody.appendChild(newRow);

                // Add event listeners to new inputs
                const inputs = newRow.querySelectorAll('input');
                inputs.forEach(input => {
                    input.addEventListener('keydown', handleInputKeydown);
                    input.addEventListener('input', handleInputChange);
                    if (input.dataset.field === 'price') {
                        input.addEventListener('focus', handlePriceFocus);
                        input.addEventListener('blur', handlePriceBlur);
                        input.addEventListener('keydown', handlePriceKeydown);
                        input.addEventListener('keyup', () => enforcePriceCaretBounds(input));
                        input.addEventListener('click', () => enforcePriceCaretBounds(input));
                    }
                });
                const priceInputNew = newRow.querySelector('input[data-field="price"]');
                if (priceInputNew) {
                    priceInputNew.addEventListener('focus', handlePriceFocus);
                    priceInputNew.addEventListener('blur', handlePriceBlur);
                }
                
                // Update JSON data after adding new row
                const metafieldContent = tableBody.closest('.metafield-content');
                if (metafieldContent) {
                    updateJSONFromTable(metafieldContent.id);
                }
                setupFirstRowPlaceholderHandlers(metafieldContent.id);
                // After adding, format all price inputs in this table to 2dp
                const table = tableBody.closest('.metafield-table');
                if (table) {
                    table.querySelectorAll('input[data-field="price"]').forEach(inp => {
                        let v = (inp.value || '').replace(/^¬£\s*/, '');
                        if (v !== '' && !isNaN(parseFloat(v))) {
                            inp.value = '¬£' + (parseFloat(v)).toFixed(2);
                        }
                    });
                }
            }
        }

        function handleInputKeydown(event) {
            // Arrow key navigation across table cells (prevent default so arrows never change values)
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                // Always prevent default arrow behavior (e.g., number increment/decrement)
                event.preventDefault();
                const inputEl = event.target;
                const row = inputEl.closest('tr');
                const tbody = row ? row.parentNode : null;
                if (!row || !tbody) return;
                const inputsInRow = Array.from(row.querySelectorAll('input'));
                const colIndex = inputsInRow.indexOf(inputEl);
                const rows = Array.from(tbody.children);
                const rowIndex = rows.indexOf(row);

                let targetRowIndex = rowIndex;
                let targetColIndex = colIndex;
                let shouldMove = false;

                if (event.key === 'ArrowUp') {
                    if (rowIndex > 0) { targetRowIndex = rowIndex - 1; shouldMove = true; }
                } else if (event.key === 'ArrowDown') {
                    if (rowIndex < rows.length - 1) { targetRowIndex = rowIndex + 1; shouldMove = true; }
                } else if (event.key === 'ArrowLeft') {
                    if (colIndex > 0) { targetColIndex = colIndex - 1; shouldMove = true; }
                    else if (rowIndex > 0) { targetRowIndex = rowIndex - 1; targetColIndex = (rows[rowIndex - 1].querySelectorAll('input').length - 1) || 0; shouldMove = true; }
                } else if (event.key === 'ArrowRight') {
                    const cols = inputsInRow.length;
                    if (colIndex < cols - 1) { targetColIndex = colIndex + 1; shouldMove = true; }
                    else if (rowIndex < rows.length - 1) { targetRowIndex = rowIndex + 1; targetColIndex = 0; shouldMove = true; }
                }

                if (shouldMove) {
                    const targetRow = rows[targetRowIndex];
                    if (targetRow) {
                        const targetInputs = targetRow.querySelectorAll('input');
                        const targetInput = targetInputs[targetColIndex] || targetInputs[targetInputs.length - 1];
                        if (targetInput) {
                            // event.preventDefault already called above
                            // place caret at end reliably (even for type=number)
                            const placeAtEnd = (el) => {
                                try {
                                    const len = (el.value || '').length;
                                    el.focus();
                                    el.setSelectionRange(len, len);
                                } catch (e) {
                                    const t = el.type;
                                    try { el.type = 'text'; const len = (el.value || '').length; el.setSelectionRange(len, len); } catch (_) {}
                                    finally { el.type = t; el.focus(); }
                                }
                            };
                            placeAtEnd(targetInput);
                        }
                    }
                }
            } else if (event.key === 'Backspace') {
                const input = event.target;
                if (input.value === '') {
                    // Check if all cells in the row are empty
                    const row = input.closest('tr');
                    const inputsInRow = row.querySelectorAll('input');
                    const allEmpty = Array.from(inputsInRow).every(input => input.value === '');
                    
                    if (allEmpty) {
                        // Prevent deletion of the first row
                        const tbody = row.parentNode;
                        const rowIndex = Array.from(tbody.children).indexOf(row);
                        const leftContent = row.closest('.metafield-content');
                        const isTradeLeft = leftContent && leftContent.id === 'trade-content';
                        const rightTbody = document.querySelector('#end-customer-content .metafield-table tbody');
                        if (rowIndex === 0) {
                            event.preventDefault();
                            return;
                        }
                        // Delete the left row
                        row.remove();
                        // Mirror deletion on right immediately when combined checkbox is on
                        if (isTradeLeft && document.getElementById('qty-match-checkbox').checked && rightTbody) {
                            const rightRow = rightTbody.children[rowIndex];
                            if (rightRow) {
                                rightTbody.removeChild(rightRow);
                                updateRowIndices(rightTbody);
                            }
                            // Recompute synced data for consistency
                            updateJSONFromTable('trade-content');
                            updateJSONFromTable('end-customer-content');
                        }
                        event.preventDefault();
                    }
                }
            } else if (event.key === 'Enter') {
                event.preventDefault();
                const currentRow = event.target.closest('tr');
                const tableBody = currentRow.parentNode;
                
                // Insert new row below current row
                insertRowBelow(currentRow, tableBody);
            }
        }

        function handleInputChange(event) {
            const input = event.target;
            const row = input.closest('tr');
            const inputsInRow = row.querySelectorAll('input');
            
            // Don't format price on every input change - let user type freely
            // Only ensure ¬£ prefix is there if the field is for price
            if (input.dataset.field === 'price') {
                let v = input.value || '';
                if (!/^¬£/.test(v) && v !== '') {
                    input.value = '¬£' + v;
                }
            }

            // Update data-index for all inputs in the row
            const rowIndex = Array.from(row.parentNode.children).indexOf(row);
            inputsInRow.forEach((input, index) => {
                input.dataset.index = rowIndex;
            });
            
            // Update JSON data from table
            const metafieldContent = input.closest('.metafield-content');
            if (metafieldContent) {
                updateJSONFromTable(metafieldContent.id);
            }
        }

        // Add a visible ¬£ prefix in the input value while keeping numeric data in JSON
        function formatPriceInputElement(input) {
            if (!input) return;
            let v = input.value || '';
            // Allow clearing to empty
            if (v === '') return;
            // Remove leading ¬£ (and optional space), then non-numeric characters except dot
            v = ('' + v).replace(/^¬£\s*/, '').replace(/[^0-9.]/g, '');
            
            // Format to 2 decimal places
            if (v && !isNaN(parseFloat(v))) {
                v = parseFloat(v).toFixed(2);
            }
            
            input.value = '¬£' + v;
        }

        function handlePriceFocus(event) {
            const input = event.target;
            let v = input.value || '';
            if (v.trim() === '') {
                input.value = '¬£';
                requestAnimationFrame(() => {
                    try { input.setSelectionRange(1, 1); } catch (e) {}
                });
            } else if (!/^¬£/.test(v)) {
                input.value = '¬£' + v.replace(/[^0-9.]/g, '');
                requestAnimationFrame(() => {
                    try { input.setSelectionRange(input.value.length, input.value.length); } catch (e) {}
                });
            }
        }

        function handlePriceBlur(event) {
            const input = event.target;
            const v = input.value || '';
            const digits = v.replace(/[^0-9.]/g, '');
            if (digits.length === 0) {
                input.value = '';
            } else {
                // Format to 2 decimal places
                if (!isNaN(parseFloat(digits))) {
                    input.value = '¬£' + parseFloat(digits).toFixed(2);
                } else {
                    input.value = '';
                }
            }
        }

        // Prevent caret from moving left of the ¬£ prefix and prevent deleting it
        function enforcePriceCaretBounds(input) {
            if (!input || !/^¬£/.test(input.value || '')) return;
            try {
                const start = input.selectionStart;
                const end = input.selectionEnd;
                if (typeof start === 'number' && start < 1) {
                    input.setSelectionRange(1, Math.max(1, end));
                }
            } catch (e) {}
        }

        function handlePriceKeydown(event) {
            const input = event.target;
            if (!(input && input.dataset && input.dataset.field === 'price')) return;
            const val = input.value || '';
            if (!/^¬£/.test(val)) return;
            if (event.key === 'Backspace') {
                try {
                    const start = input.selectionStart;
                    const end = input.selectionEnd;
                    if (typeof start === 'number' && typeof end === 'number' && start <= 1 && end <= 1) {
                        event.preventDefault();
                        input.setSelectionRange(1, 1);
                    }
                } catch (e) {}
            } else if (event.key === 'Home') {
                event.preventDefault();
                try { input.setSelectionRange(1, 1); } catch (e) {}
            }
        }

        function insertRowBelow(currentRow, tableBody) {
            const newRow = document.createElement('tr');
            const currentIndex = Array.from(tableBody.children).indexOf(currentRow);
            
            newRow.innerHTML = `
                <td><input type="number" value="" data-index="${currentIndex + 1}" data-field="min" placeholder=""></td>
                <td><input type="number" value="" data-index="${currentIndex + 1}" data-field="max" placeholder=""></td>
                <td><div class="currency-input"><input type="text" inputmode="decimal" value="" data-index="${currentIndex + 1}" data-field="price" placeholder=""></div></td>
            `;
            
            // Insert the new row after the current row
            if (currentRow.nextSibling) {
                tableBody.insertBefore(newRow, currentRow.nextSibling);
            } else {
                tableBody.appendChild(newRow);
            }
            
            // Add event listeners to new inputs
            const inputs = newRow.querySelectorAll('input');
            inputs.forEach(input => {
                input.addEventListener('keydown', handleInputKeydown);
                input.addEventListener('input', handleInputChange);
                if (input.dataset.field === 'price') {
                    input.addEventListener('focus', handlePriceFocus);
                    input.addEventListener('blur', handlePriceBlur);
                    input.addEventListener('keydown', handlePriceKeydown);
                    input.addEventListener('keyup', () => enforcePriceCaretBounds(input));
                    input.addEventListener('click', () => enforcePriceCaretBounds(input));
                }
            });
            const p = newRow.querySelector('input[data-field="price"]');
            if (p) {
                p.addEventListener('focus', handlePriceFocus);
                p.addEventListener('blur', handlePriceBlur);
            }
            
            // Update data indices for all rows after the new row
            updateRowIndices(tableBody);
            
            // Update JSON data after adding new row
            const metafieldContent = tableBody.closest('.metafield-content');
            if (metafieldContent) {
                updateJSONFromTable(metafieldContent.id);
            }
            
            // Focus on the first input of the new row
            newRow.querySelector('input[data-field="min"]').focus();
            setupFirstRowPlaceholderHandlers(metafieldContent.id);
            // Format all price inputs in this table to 2dp on Enter
            const table = tableBody.closest('.metafield-table');
            if (table) {
                table.querySelectorAll('input[data-field="price"]').forEach(inp => {
                    let v = (inp.value || '').replace(/^¬£\s*/, '');
                    if (v !== '' && !isNaN(parseFloat(v))) {
                        inp.value = '¬£' + (parseFloat(v)).toFixed(2);
                    }
                });
            }
        }

        function updateRowIndices(tableBody) {
            const rows = tableBody.querySelectorAll('tr');
            rows.forEach((row, index) => {
                const inputs = row.querySelectorAll('input');
                inputs.forEach(input => {
                    input.dataset.index = index;
                });
            });
        }

        function updateJSONFromTable(contentId) {
            const content = document.getElementById(contentId);
            const tableElement = content.querySelector('.metafield-table');
            
            if (!tableElement || tableElement.style.display === 'none') {
                return; // Table not visible
            }
            
            const rows = tableElement.querySelectorAll('tbody tr');
            const newData = [];
            
            rows.forEach(row => {
                const inputs = row.querySelectorAll('input');
                if (inputs.length === 3) {
                    const min = parseFloat(inputs[0].value);
                    const max = parseFloat(inputs[1].value);
                    let priceStr = inputs[2].value;
                    // Strip a leading ¬£ if user typed one
                    if (typeof priceStr === 'string') {
                        priceStr = priceStr.trim().replace(/^¬£\s*/, '');
                    }
                    const price = parseFloat(priceStr);
                    
                    if (!isNaN(min) && !isNaN(max) && !isNaN(price)) {
                        // Format price to 2 decimal places as a string
                        const formattedPrice = parseFloat(price).toFixed(2);
                        newData.push({ min, max, price: formattedPrice });
                    }
                }
            });
            
            // Update the current data based on content ID
            if (contentId === 'trade-content') {
                currentPriceData.trade = newData;
                
                // If combined checkbox is enabled, sync the end customer table using LEFT DOM rows (so row count mirrors left even if incomplete)
                if (document.getElementById('qty-match-checkbox').checked) {
                    const tradeRows = Array.from(tableElement.querySelectorAll('tbody tr'));
                    const rowsForSync = tradeRows.map((row, idx) => {
                        const inputs = row.querySelectorAll('input');
                        const minVal = parseFloat(inputs[0]?.value);
                        const maxVal = parseFloat(inputs[1]?.value);
                        let priceStr = inputs[2]?.value;
                        if (typeof priceStr === 'string') priceStr = priceStr.trim().replace(/^¬£\s*/, '');
                        const priceVal = parseFloat(priceStr);
                        const existingPrice = currentPriceData.trade?.[idx]?.price;
                        // Format price to 2 decimal places
                        let formattedPrice;
                        if (Number.isFinite(priceVal)) {
                            formattedPrice = parseFloat(priceVal).toFixed(2);
                        } else if (existingPrice) {
                            // If using existing price, ensure it's formatted
                            formattedPrice = typeof existingPrice === 'string' ? existingPrice : parseFloat(existingPrice).toFixed(2);
                        } else {
                            formattedPrice = '0.00';
                        }
                        return {
                            min: Number.isFinite(minVal) ? minVal : '',
                            max: Number.isFinite(maxVal) ? maxVal : '',
                            price: formattedPrice
                        };
                    });
                    syncEndCustomerQuantityRanges(rowsForSync);
                }
                
                // With combined checkbox, also sync prices
                if (document.getElementById('qty-match-checkbox').checked) {
                    syncPricesFromTrade();
                }
            } else if (contentId === 'end-customer-content') {
                currentPriceData.endCustomer = newData;
            }
        }

        function syncQuantityRanges() {
            const tradeData = currentPriceData.trade || [];
            if (tradeData.length > 0) {
                syncEndCustomerQuantityRanges(tradeData);
            }
        }

        function syncEndCustomerQuantityRanges(tradeData) {
            if (!Array.isArray(tradeData) || tradeData.length === 0) return;
            
            const endCustomerTable = document.querySelector('#end-customer-content .metafield-table tbody');
            if (!endCustomerTable) return;
            
            // Get current end customer data to preserve prices
            const currentEndCustomerData = currentPriceData.endCustomer || [];
            
            // Create a map of existing prices by row index
            const existingPrices = [];
            currentEndCustomerData.forEach(item => {
                existingPrices.push(item.price);
            });
            
            // Clear and rebuild the end customer table with trade quantity ranges
            endCustomerTable.innerHTML = '';
            
            tradeData.forEach((tradeItem, index) => {
                const row = document.createElement('tr');
                
                // Calculate price based on price sync checkbox
                let priceText = '';
                if (document.getElementById('qty-match-checkbox').checked) {
                    // Only compute uplift if left price is numeric; otherwise keep blank
                    const raw = tradeData[index] ? tradeData[index].price : undefined;
                    const parsed = parseFloat(raw);
                    if (Number.isFinite(parsed)) {
                        priceText = (parsed * 1.3).toFixed(2);
                    } else {
                        priceText = '';
                    }
                } else {
                    // Preserve existing right-side price if present; otherwise blank
                    const preserved = existingPrices[index];
                    if (preserved !== undefined && preserved !== null) {
                        // Handle both string and number formats
                        const priceNum = typeof preserved === 'string' ? parseFloat(preserved) : preserved;
                        priceText = Number.isFinite(priceNum) ? parseFloat(priceNum).toFixed(2) : '';
                    } else {
                        priceText = '';
                    }
                }
                
                row.innerHTML = `
                    <td><input type="number" value="${tradeItem.min}" data-index="${index}" data-field="min"></td>
                    <td><input type="number" value="${tradeItem.max}" data-index="${index}" data-field="max"></td>
                    <td><div class="currency-input"><input type="text" inputmode="decimal" value="${priceText ? ('¬£' + priceText) : ''}" data-index="${index}" data-field="price" placeholder=""></div></td>
                `;
                endCustomerTable.appendChild(row);
                
                // Add event listeners to new inputs
                const inputs = row.querySelectorAll('input');
                inputs.forEach(input => {
                    input.addEventListener('keydown', handleInputKeydown);
                    input.addEventListener('input', handleInputChange);
                });
                const priceInput = row.querySelector('input[data-field="price"]');
                if (priceInput) {
                    priceInput.addEventListener('focus', handlePriceFocus);
                    priceInput.addEventListener('blur', handlePriceBlur);
                    if ((priceInput.value || '').trim() !== '') {
                        formatPriceInputElement(priceInput);
                    }
                }
            });
            // ensure lock state after rebuild
            updateEndCustomerEditability();
            
            // Update the current data
            const newEndCustomerData = Array.from(endCustomerTable.querySelectorAll('tr')).map(row => {
                const inputs = row.querySelectorAll('input');
                let priceStr = inputs[2].value;
                // Strip a leading ¬£ if user typed one
                if (typeof priceStr === 'string') {
                    priceStr = priceStr.trim().replace(/^¬£\s*/, '');
                }
                const price = parseFloat(priceStr);
                return {
                    min: parseFloat(inputs[0].value),
                    max: parseFloat(inputs[1].value),
                    price: !isNaN(price) ? parseFloat(price).toFixed(2) : '0.00'
                };
            });
            
            currentPriceData.endCustomer = newEndCustomerData;
        }

        function syncPricesFromTrade() {
            const tradeData = currentPriceData.trade || [];
            const endCustomerTable = document.querySelector('#end-customer-content .metafield-table tbody');
            
            if (!Array.isArray(tradeData) || tradeData.length === 0 || !endCustomerTable) return;
            
            // Get all rows in the end customer table
            const rows = endCustomerTable.querySelectorAll('tr');
            
            rows.forEach((row, index) => {
                const priceInput = row.querySelector('input[data-field="price"]');
                if (priceInput && tradeData[index]) {
                    // Calculate 30% higher than trade price (handle both string and number)
                    const tradePrice = typeof tradeData[index].price === 'string' ? parseFloat(tradeData[index].price) : tradeData[index].price;
                    const newPrice = tradePrice * 1.3;
                    priceInput.value = '¬£' + newPrice.toFixed(2);
                    
                    // Trigger input change event to update the data
                    priceInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            });
        }

        function collectPriceData() {
            // Keep prices as strings to preserve "2.00" format in saved JSON metafields
            // The saved metafields (pricejsontr/pricejsoner) will have prices as strings like "2.00"
            return {
                trade: currentPriceData.trade || [],
                endCustomer: currentPriceData.endCustomer || []
            };
        }


        // Load metafields automatically when page loads - using specific template product
        async function loadMetafields() {
            try {
                console.log('Loading metafields from template product ID: 15285916696954...');
                
                // Use the specific product ID as template for metafield structure
                const templateProductId = 15285916696954;
                
                // Fetch detailed product information including metafields
                const productResponse = await fetch(`/api/product/${templateProductId}`);
                console.log('Template product API response status:', productResponse.status);
                
                if (productResponse.ok) {
                    const productData = await productResponse.json();
                    console.log('Template product data received:', productData);
                    
                    // Clear all values from metafields so they're empty for the new product
                    const emptyMetafields = (productData.metafields || []).map(metafield => ({
                        ...metafield,
                        value: '', // Clear the value so it's empty for the new product
                        id: null   // Clear the ID since this is for a new product
                    }));
                    
                    console.log('Displaying metafields with cleared values for new product');
                    displayMetafields(emptyMetafields);
                } else {
                    const errorText = await productResponse.text();
                    console.log(`Error fetching template product details: ${productResponse.statusText}`);
                    console.log('Error response:', errorText);
                    showMetafieldsError();
                }
            } catch (error) {
                console.log('Error loading metafields:', error.message);
                console.error('Full error:', error);
                showMetafieldsError();
            }
        }

        // Convert technical metafield keys to human-readable names
        function getHumanReadableName(key) {
            const nameMap = {
                // Dietary restrictions
                'vegan': 'Suitable for: Vegans',
                'vegetarian': 'Suitable for: Vegetarians', 
                'halal': 'Suitable for: Halal',
                'coeliac': 'Suitable for: Coeliacs',
                'peanuts': 'Contains: Peanuts',
                'tree_nuts': 'Contains: Tree Nuts',
                'sesame': 'Contains: Sesame',
                'egg': 'Contains: Eggs',
                'cereals': 'Contains: Cereals',
                'soya': 'Contains: Soya',
                'milk': 'Contains: Milk',
                'egg': 'Contains: Egg',
                'moq': 'MOQ (Units)',
                'origination': 'Origination (¬£)',
                'shelf_life': 'Shelf Life (Months)',
                'unit_weight': 'Unit Weight (g)',
                'case_weight': 'Case Weight (g)',
                'print_info': 'Print Info',
                'case_quantity': 'Case Quantity (Units)',
                'ingredients': 'Ingredients',
                'nutritional_info': 'Nutritional Info',
                'whats_inside': 'What\'s Inside',
                'artworktemplates': 'Artwork Templates',
                'artworkguidelines': 'Artwork Guidelines',
                'description': 'Description',
                'leadtime1': 'Lead Time <5000 units (Days)',
                'leadtime2': 'Lead Time 5000-10000 units (Days)',
                'sku': 'Product Code',
                'recycle_info': 'Recycle Info',
                'commodity_code': 'Commodity Code',
                'product_size': 'Product Size in mm (l*w*h)',
                'custom_category': 'Category',
                'subcategory': 'Subcategory',
                
                // Default fallback - capitalize and replace underscores
                'default': key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
            };
            
            // Check if we have a specific mapping
            if (nameMap[key]) {
                return nameMap[key];
            }
            
            // Use the default transformation
            return nameMap.default;
        }

        // Display metafields in 3-column grid - using Field_Finder logic
        function displayMetafields(metafields) {
            console.log('üîç displayMetafields called with:', metafields);
            console.log('üîç Total metafields to display:', metafields.length);
            
            const container = document.getElementById('metafields-container');
            container.innerHTML = '';
            
            if (metafields.length === 0) {
                container.innerHTML = '<p style="color: #666; font-style: italic; grid-column: 1 / -1;">No metafields found</p>';
                return;
            }

            // Default metafield order (hardcoded fallback)
            const DEFAULT_METAFIELD_ORDER = [
                "sku",
                "custom_category", 
                "subcategory",
                "description",
                "moq",
                "origination",
                "shelf_life",
                "unit_weight",
                "case_quantity",
                "case_weight",
                "print_info",
                "recycle_info",
                "ingredients",
                "nutritional_info",
                "leadtime1",
                "leadtime2",
                "whats_inside",
                "vegan",
                "vegetarian",
                "halal",
                "coeliac",
                "peanuts",
                "tree_nuts",
                "sesame",
                "milk",
                "egg",
                "cereals",
                "soya",
                "product_size",
                "commodity_code",
                "packing_info"
            ];

            // Mirror Field Finder: apply saved box order from localStorage (metafieldOrder)
            try {
                const saved = localStorage.getItem('metafieldOrder');
                let order = DEFAULT_METAFIELD_ORDER; // Use default as fallback
                
                if (saved) {
                    const parsedOrder = JSON.parse(saved);
                    if (Array.isArray(parsedOrder) && parsedOrder.length > 0) {
                        order = parsedOrder; // Use saved order if valid
                    }
                }
                
                        const byKey = new Map();
                        metafields.forEach(m => byKey.set(m.key, m));
                        const ordered = [];
                        order.forEach(k => { if (byKey.has(k)) { ordered.push(byKey.get(k)); byKey.delete(k); } });
                        metafields = ordered.concat(Array.from(byKey.values()));
            } catch (e) { /* ignore ordering errors */ }

            // Mirror Field Finder hidden logic
            try {
                metafields = (metafields || []).filter(m => {
                    const namespace = (m.namespace || '').toLowerCase();
                    const key = (m.key || '').toLowerCase();
                    if (!namespace || !key) return false;
                    if (namespace === 'global') return false;
                    if (key.startsWith('pricejson') && !key.includes('.')) return false;
                    if (namespace === 'shopify' && key.includes('chocolate')) return false;
                    if (namespace === 'custom' && ['artworkguidelines','artworktemplates','packaging if applicable','packaging_if_applicable','product_colours'].includes(key)) return false;
                    return true;
                });
            } catch (e) { /* ignore filter errors */ }

            for (const metafield of metafields) {
                console.log(`üîç Processing metafield ${metafield.key}:`, metafield);
                console.log(`üìä Raw available_options for ${metafield.key}:`, metafield.available_options);
                
                const metafieldDiv = document.createElement('div');
                metafieldDiv.className = 'metafield-item';
                
                // Create a more readable display name by converting technical keys to human-readable names
                let displayName = getHumanReadableName(metafield.key);
                
                // Check if this metafield should have emoji buttons
                const emojiFields = ['vegan', 'vegetarian', 'halal', 'coeliac', 'peanuts', 'tree_nuts', 'sesame', 'egg', 'cereals', 'soya', 'milk'];
                const hasEmojiButtons = emojiFields.includes(metafield.key);
                
                // Special handling for product_size field - create 3 separate input fields
                const isProductSize = metafield.key === 'product_size';
                
                // Check if this metafield has predefined options (list types OR single_line_text_field with choices)
                // BUT emoji fields should always use textareas, not dropdowns
                // AND only show dropdowns if there are actually multiple real options (not just the current value)
                const isCategoryField = metafield.key === 'custom_category' || metafield.key === 'subcategory';
                if (isCategoryField) {
                    console.log(`üîç Processing category field: ${metafield.key}`);
                }
                
                const hasOptions = (!hasEmojiButtons && (metafield.available_options && metafield.available_options.length > 1));
                const currentValue = metafield.value || '';
                
                // For fields with multiple real options (but NOT emoji fields), create a dropdown; otherwise use textarea
                let inputElement;
                
                console.log(`üîç Processing ${metafield.key}: isProductSize=${isProductSize}, hasEmojiButtons=${hasEmojiButtons}, hasOptions=${hasOptions}`);
                
                // Special case for product_size - create 3 separate input fields
                if (isProductSize) {
                    const sizeParts = currentValue.split('*').map(part => part.trim());
                    const length = sizeParts[0] || '';
                    const width = sizeParts[1] || '';
                    const height = sizeParts[2] || '';
                    
                    inputElement = `
                        <div class="product-size-inputs" style="display: flex; align-items: center; gap: 10px;">
                            <input type="text" class="metafield-value product-size-field" data-key="${metafield.key || ''}" data-namespace="${metafield.namespace || 'custom'}" data-type="${metafield.type || 'single_line_text_field'}" data-part="length" placeholder="Length" value="${length}" style="flex: 1; padding: 8px;">
                            <span style="font-size: 18px; font-weight: bold;">*</span>
                            <input type="text" class="metafield-value product-size-field" data-key="${metafield.key || ''}" data-namespace="${metafield.namespace || 'custom'}" data-type="${metafield.type || 'single_line_text_field'}" data-part="width" placeholder="Width" value="${width}" style="flex: 1; padding: 8px;">
                            <span style="font-size: 18px; font-weight: bold;">*</span>
                            <input type="text" class="metafield-value product-size-field" data-key="${metafield.key || ''}" data-namespace="${metafield.namespace || 'custom'}" data-type="${metafield.type || 'single_line_text_field'}" data-part="height" placeholder="Height" value="${height}" style="flex: 1; padding: 8px;">
                        </div>
                    `;
                } else if (metafield.key === 'custom_category') {
                    // Special handling for category field - create custom dropdown menu
                    console.log(`üîß Creating custom dropdown for ${metafield.key}`);
                        inputElement = `
                        <div class="custom-dropdown" data-id="${metafield.id || 'null'}" data-namespace="${metafield.namespace || 'custom'}" data-key="${metafield.key || ''}" data-type="list.single_line_text_field">
                            <div class="dropdown-button" onclick="toggleDropdown(this)">
                                <span class="dropdown-text">Select categories...</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="dropdown-content" style="display: none;">
                                <div class="dropdown-loading">Loading options...</div>
                            </div>
                        </div>
                    `;
                    console.log(`‚úÖ Custom dropdown HTML created for ${metafield.key}:`, inputElement);
                } else if (metafield.key === 'subcategory') {
                    // Special handling for subcategory field - create custom dropdown menu
                    console.log(`üîß Creating custom dropdown for ${metafield.key}`);
                    inputElement = `
                        <div class="custom-dropdown" data-id="${metafield.id || 'null'}" data-namespace="${metafield.namespace || 'custom'}" data-key="${metafield.key || ''}" data-type="list.single_line_text_field">
                            <div class="dropdown-button" onclick="toggleDropdown(this)">
                                <span class="dropdown-text">Select subcategories...</span>
                                <span class="dropdown-arrow">‚ñº</span>
                            </div>
                            <div class="dropdown-content" style="display: none;">
                                <div class="dropdown-loading">Loading options...</div>
                            </div>
                        </div>
                    `;
                    console.log(`‚úÖ Custom dropdown HTML created for ${metafield.key}:`, inputElement);
                } else if (hasOptions) {
                    console.log(`üîß Creating dropdown for ${metafield.key} (hasOptions)`);
                        // Use Shopify's predefined options
                        if (metafield.available_options && metafield.available_options.length > 0) {
                            availableOptions = metafield.available_options;
                            console.log(`üìã Using Shopify options for ${metafield.key}:`, availableOptions);
                        } else {
                            // Fallback to parsing current value if no predefined options
                            availableOptions = currentValue ? currentValue.split(',').map(v => v.trim()).filter(v => v) : [];
                            console.log(`üìù Fallback to parsed options for ${metafield.key}:`, availableOptions);
                        }
                        
                        // Clean up options - remove quotes, brackets, and extra whitespace
                        availableOptions = availableOptions.map(option => {
                            if (typeof option === 'string') {
                            return option.replace(/["\[\]]/g, '').trim();
                            }
                        return String(option).replace(/["\[\]]/g, '').trim();
                        }).filter(option => option && option !== '');
                        
                        // Add current value if it's not in the available options
                        if (currentValue && !availableOptions.includes(currentValue)) {
                        const cleanCurrentValue = currentValue.replace(/["\[\]]/g, '').trim();
                            if (cleanCurrentValue && !availableOptions.includes(cleanCurrentValue)) {
                                availableOptions.unshift(cleanCurrentValue);
                            }
                        }
                        
                        console.log(`üéØ Final cleaned options for ${metafield.key}:`, availableOptions);
                        
                        inputElement = `
                            <select class="metafield-value list-dropdown" data-id="${metafield.id || 'null'}" data-namespace="${metafield.namespace || 'custom'}" data-key="${metafield.key || ''}" data-type="${metafield.type || 'single_line_text_field'}">
                                <option value="">-- Select Option --</option>
                                ${availableOptions.map(option => `<option value="${option}" ${currentValue === option ? 'selected' : ''}>${option}</option>`).join('')}
                            </select>
                        `;
                } else if (hasEmojiButtons) {
                    console.log(`üîß Creating emoji buttons for ${metafield.key}`);
                    // Create button-only interface for emoji fields (no textarea)
                    inputElement = `
                        <div class="emoji-field-container" data-id="${metafield.id || 'null'}" data-namespace="${metafield.namespace || 'custom'}" data-key="${metafield.key || ''}" data-type="${metafield.type || 'single_line_text_field'}">
                            <div class="emoji-buttons">
                                <button type="button" class="emoji-btn tick ${currentValue === '‚úîÔ∏è' ? 'selected' : ''}" data-emoji="‚úîÔ∏è">
                                    <span>‚úîÔ∏è</span>
                                </button>
                                <button type="button" class="emoji-btn cross ${currentValue === '‚ùå' ? 'selected' : ''}" data-emoji="‚ùå">
                                    <span>‚ùå</span>
                                </button>
                            </div>
                        </div>
                    `;
                } else {
                    console.log(`üîß Creating textarea for ${metafield.key}`);
                    // Regular textarea for non-list types
                    inputElement = `<textarea class="metafield-value" data-id="${metafield.id || 'null'}" data-namespace="${metafield.namespace || 'custom'}" data-key="${metafield.key || ''}" data-type="${metafield.type || 'single_line_text_field'}">${currentValue}</textarea>`;
                }
                
                console.log(`üéØ Final inputElement for ${metafield.key}:`, inputElement);
                
                metafieldDiv.innerHTML = `
                    <div class="metafield-header">
                        <span class="metafield-name" data-key="${metafield.key || ''}">${displayName}</span>
                </div>
                    <div class="metafield-input-row">
                        ${inputElement}
                    </div>
                    <div class="metafield-footer">
                        <span class="metafield-type">${metafield.type}</span>
                        <span class="metafield-key">${metafield.namespace}:${metafield.key}</span>
                    </div>
                `;
                
                // Debug: Check if dropdown was created for category/subcategory
                if (metafield.key === 'custom_category' || metafield.key === 'subcategory') {
                    const createdSelect = metafieldDiv.querySelector('select.metafield-value');
                    console.log(`üîç After HTML creation, select element for ${metafield.key}:`, createdSelect);
                    if (createdSelect) {
                        console.log(`‚úÖ Select element found for ${metafield.key}`);
                    } else {
                        console.log(`‚ùå Select element NOT found for ${metafield.key}`);
                    }
                }
                
                container.appendChild(metafieldDiv);

                // Add event listeners for emoji buttons
                if (hasEmojiButtons) {
                    const emojiButtons = metafieldDiv.querySelectorAll('.emoji-btn');
                    emojiButtons.forEach(button => {
                        button.addEventListener('click', () => selectEmoji(button));
                    });
                }

                // For custom dropdowns, load options immediately and set initial values
                if (metafield.key === 'custom_category' || metafield.key === 'subcategory') {
                    const dropdown = metafieldDiv.querySelector('.custom-dropdown');
                    if (dropdown) {
                        // Load options immediately
                        const loadFunc = metafield.key === 'custom_category' ? loadCategoryDropdownOptions : loadSubcategoryDropdownOptions;
                        loadFunc(dropdown).then(() => {
                            // After options are loaded, set the initial values
                            if (metafield.value) {
                                let currentValues = [];
                                if (Array.isArray(metafield.value)) {
                                    currentValues = metafield.value;
                                } else if (typeof metafield.value === 'string') {
                                    // Try to parse as JSON array
                                    try {
                                        const parsed = JSON.parse(metafield.value);
                                        currentValues = Array.isArray(parsed) ? parsed : [metafield.value];
                                    } catch {
                                        currentValues = [metafield.value];
                                    }
                                }
                                
                                // Set checkboxes as checked
                                currentValues.forEach(val => {
                                    const checkbox = dropdown.querySelector(`input[type="checkbox"][value="${val}"]`);
                                    if (checkbox) {
                                        checkbox.checked = true;
                                    }
                                });
                                
                                // Update the dropdown text
                                updateDropdownText(dropdown);
                                console.log(`‚úÖ Set initial ${metafield.key} values:`, currentValues);
                            }
                        });
                    }
                }
            }
            
            // After all metafields are displayed, set up auto-calculation for case weight
            setupCaseWeightCalculation();

            // Set default lead times if empty
            setDefaultLeadTimes();
            
            // Set default origination if empty
            setDefaultOrigination();
        }

        // Auto-calculation function for case weight
        function setupCaseWeightCalculation() {
            const caseWeightField = document.querySelector('textarea[data-key="case_weight"]');
            const caseQuantityField = document.querySelector('textarea[data-key="case_quantity"]');
            const unitWeightField = document.querySelector('textarea[data-key="unit_weight"]');
            
            if (caseWeightField && caseQuantityField && unitWeightField) {
                console.log('üîß Setting up case weight auto-calculation');
                
                // Function to calculate case weight
                function calculateCaseWeight() {
                    const caseQuantity = parseFloat(caseQuantityField.value) || 0;
                    const unitWeight = parseFloat(unitWeightField.value) || 0;
                    
                    if (caseQuantity > 0 && unitWeight > 0) {

                        // Calculate base weight
                        const baseWeight = caseQuantity * unitWeight;
                        
                        // Add buffer based on weight: 100 for every 1000 (minimum 100 for < 1000)
                        // If baseWeight < 1000: add 100
                        // If baseWeight >= 1000 and < 2000: add 200 (which is 2 * 100)
                        // Pattern: add 100 for every 1000
                        let buffer;
                        if (baseWeight < 1000) {
                            buffer = 100;
                        } else {
                            // For weights >= 1000, calculate how many multiples of 1000
                            // For 1000-1999: Math.floor(1000/1000) = 1, but we want 2, so add 1
                            // Formula: (Math.floor(baseWeight / 1000) + 1) * 100
                            // This gives: 1000-1999 = 2*100 = 200, 2000-2999 = 3*100 = 300, etc.
                            buffer = (Math.floor(baseWeight / 1000) + 1) * 100;
                        }
                        
                        const calculatedWeight = baseWeight + buffer;
                        caseWeightField.value = calculatedWeight;
                        console.log(`üßÆ Auto-calculated case weight: ${caseQuantity} √ó ${unitWeight} = ${baseWeight} + ${buffer} buffer = ${calculatedWeight}`);
                        
                        // Trigger change event to mark as modified
                        caseWeightField.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }
                
                // Add event listeners to trigger calculation when values change
                caseQuantityField.addEventListener('input', calculateCaseWeight);
                unitWeightField.addEventListener('input', calculateCaseWeight);
                
                // Initial calculation if values are already present
                if (caseQuantityField.value && unitWeightField.value) {
                    calculateCaseWeight();
                }
                
                console.log('‚úÖ Case weight auto-calculation set up');
            } else {
                console.log('‚ö†Ô∏è Could not set up case weight auto-calculation - missing fields');
            }
        }

        // Autofill lead times if empty
        function setDefaultLeadTimes() {
            try {
                // leadtime1 -> 5
                const lt1Textarea = document.querySelector('textarea[data-key="leadtime1"]');
                const lt1Select = document.querySelector('select[data-key="leadtime1"]');
                if (lt1Textarea && (!lt1Textarea.value || lt1Textarea.value.trim() === '')) {
                    lt1Textarea.value = '5';
                    lt1Textarea.dispatchEvent(new Event('input', { bubbles: true }));
                } else if (lt1Select) {
                    // If it's a select, try to select option '5'
                    const opt = Array.from(lt1Select.options).find(o => o.value.trim() === '5');
                    if (opt) {
                        lt1Select.value = '5';
                        lt1Select.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }

                // leadtime2 -> 10
                const lt2Textarea = document.querySelector('textarea[data-key="leadtime2"]');
                const lt2Select = document.querySelector('select[data-key="leadtime2"]');
                if (lt2Textarea && (!lt2Textarea.value || lt2Textarea.value.trim() === '')) {
                    lt2Textarea.value = '10';
                    lt2Textarea.dispatchEvent(new Event('input', { bubbles: true }));
                } else if (lt2Select) {
                    const opt2 = Array.from(lt2Select.options).find(o => o.value.trim() === '10');
                    if (opt2) {
                        lt2Select.value = '10';
                        lt2Select.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }
            } catch (e) {
                console.log('Leadtime defaults not applied:', e.message);
            }
        }

        // Autofill origination if empty
        function setDefaultOrigination() {
            try {
                // origination -> 50
                const origTextarea = document.querySelector('textarea[data-key="origination"]');
                const origSelect = document.querySelector('select[data-key="origination"]');
                if (origTextarea && (!origTextarea.value || origTextarea.value.trim() === '')) {
                    origTextarea.value = '50';
                    origTextarea.dispatchEvent(new Event('input', { bubbles: true }));
                } else if (origSelect) {
                    const opt = Array.from(origSelect.options).find(o => o.value.trim() === '50');
                    if (opt) {
                        origSelect.value = '50';
                        origSelect.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }
            } catch (e) {
                console.log('Origination default not applied:', e.message);
            }
        }
        
        // Handle emoji button selection (new button-only approach)
        function selectEmoji(button) {
            const emojiFieldContainer = button.closest('.emoji-field-container');
            const allButtons = emojiFieldContainer.querySelectorAll('.emoji-btn');
            const selectedEmoji = button.dataset.emoji;
            
            // Check if this button is already selected
            if (button.classList.contains('selected')) {
                // If already selected, deselect it
                button.classList.remove('selected');
                emojiFieldContainer.dataset.selectedValue = '';
                console.log(`‚úÖ Deselected ${selectedEmoji} for ${emojiFieldContainer.dataset.key || 'unknown field'}`);
            } else {
                // Remove selected class from all buttons
                allButtons.forEach(btn => btn.classList.remove('selected'));
                
                // Add selected class to clicked button
                button.classList.add('selected');
                
                // Store the selected value in the container
                emojiFieldContainer.dataset.selectedValue = selectedEmoji;
                
                console.log(`‚úÖ Selected ${selectedEmoji} for ${emojiFieldContainer.dataset.key || 'unknown field'}`);
            }
            
            // Trigger change event
            emojiFieldContainer.dispatchEvent(new Event('change', { bubbles: true }));
        }

        function showMetafieldsError() {
            const container = document.getElementById('metafields-container');
            container.innerHTML = `
                <div class="metafields-error">
                    <i class="fas fa-exclamation-triangle"></i>
                    <span>Failed to load metafields</span>
                </div>
            `;
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.settings-dropdown')) {
                document.getElementById('settings-menu').classList.remove('visible');
            }
        });

        // Load metafields when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadMetafields();
            initializePriceManager();
            fetchPricingQtyBands();
        });

        function toggleConverter() {
            const textarea = document.getElementById('description');
            const convertBtn = document.getElementById('convertBtn');
            const convertText = document.getElementById('convertText');
            
            // Temporarily make textarea editable for conversion
            textarea.readOnly = false;
            
            if (isHtmlMode) {
                // Convert HTML to plain text
                textarea.value = htmlToText(textarea.value);
                isHtmlMode = false;
            } else {
                // Convert plain text to HTML
                textarea.value = textToHtml(textarea.value);
                isHtmlMode = true;
            }
            
            // Make textarea read-only again after conversion
            textarea.readOnly = true;
            
            updateConverterButton();
        }

        function updateConverterButton() {
            const convertText = document.getElementById('convertText');
            const convertBtn = document.getElementById('convertBtn');
            
            if (isHtmlMode) {
                convertText.textContent = 'Convert to Text';
                convertBtn.innerHTML = '<i class="fas fa-file-text"></i><span id="convertText">Convert to Text</span>';
            } else {
                convertText.textContent = 'Convert to HTML';
                convertBtn.innerHTML = '<i class="fas fa-code"></i><span id="convertText">Convert to HTML</span>';
            }
        }

        function textToHtml(text) {
            // Convert plain text to HTML format with the original working format
            console.log('üîç textToHtml input:', JSON.stringify(text));
            const result = text
                .split('\n')
                .map(line => {
                    line = line.trim();
                    if (line === '') return '';
                    return `<h3><span>${line}</span><span></span></h3>`;
                })
                .join('\n');
            console.log('üîç textToHtml output:', JSON.stringify(result));
            return result;
        }

        function htmlToText(html) {
            // Convert HTML back to plain text, but preserve the heading structure
            return html
                .replace(/<h3><span>(.*?)<\/span><span><\/span><\/h3>/g, '$1') // Handle original format
                .replace(/<h3><span>(.*?)<\/span><\/h3>/g, '$1') // Handle variant format
                .replace(/<h3>(.*?)<\/h3>/g, '$1') // Extract text from simple h3 tags
                .replace(/<br\s*\/?>/g, '\n') // Convert <br> tags to newlines
                .replace(/<[^>]*>/g, '') // Remove any remaining HTML tags
                .trim();
        }


        // Form submission
        document.getElementById('productForm').addEventListener('submit', async function(e) {
            console.log('üö® Form submission triggered!', e);
            e.preventDefault();
            
            // Validate required fields
            const title = document.getElementById('title').value.trim();
            if (!title) {
                alert('Please enter a product title before creating the product.');
                return;
            }
            
            console.log('‚úÖ Product creation initiated');
            
            const formData = new FormData(this);
            const productData = {};
            
            // Basic fields
            productData.title = formData.get('title') || '';
            
            // Convert description to HTML if it's in text mode
            let description = formData.get('description') || '';
            console.log('üîç Raw description from form:', JSON.stringify(description));
            console.log('üîç isHtmlMode:', isHtmlMode);
            console.log('üîç Description length:', description.length);
            console.log('üîç Description contains newlines:', description.includes('\n'));
            if (!isHtmlMode) {
                description = textToHtml(description);
                console.log('üîç Converted to HTML:', JSON.stringify(description));
            } else {
                console.log('üîç Keeping as HTML (not converting)');
            }
            // If it's already HTML mode, keep it as is
            productData.description = description;
            console.log('üîç Final description being sent:', JSON.stringify(description));
            
            productData.status = formData.get('status') || 'active';
            productData.tags = getVatTag();
            productData.charge_vat = document.getElementById('chargeVatYes').checked;
            
            // Get colour options from multiple inputs (new format with separate name/code)
            const colourCells = document.querySelectorAll('.colour-cell');
            const colours = [];
            const colourImages = {};
            colourCells.forEach((cell, index) => {
                const nameInput = cell.querySelector('.colour-name-input');
                const codeInput = cell.querySelector('.colour-code-input');
                const name = nameInput ? nameInput.value.trim() : '';
                const code = codeInput ? codeInput.value.trim() : '';
                if (name) {
                    // Format as "Colour:Code" or just "Colour" if no code
                    colours.push(code ? `${name}:${code}` : name);
                    // Store image mapping if exists - use the media index
                    if (colourImageMap[index] !== undefined) {
                        // Store the index to match the order when images are attached
                        colourImages[name] = colourImageMap[index];
                    }
                }
            });
            productData.product_colours = colours.join(', ');
            productData.colour_images = colourImages; // Store colour to image mapping
            
            console.log('üîç Colour cells found:', colourCells.length);
            console.log('üîç Colours collected:', colours);
            console.log('üîç Product colours string:', productData.product_colours);
            console.log('üîç Colour images mapping:', colourImages);
            
            // Require SKU metafield before creating product
            try {
                const mfSkuInput = document.querySelector('.metafield-value[data-namespace="custom"][data-key="sku"]');
                const skuValue = mfSkuInput ? (mfSkuInput.value || '').trim() : '';
                if (!skuValue) {
                    alert('Please enter a SKU in the SKU metafield before creating the product.');
                    return;
                }
            } catch (e) {}
            
            // Pricing fields - using default values since fields were removed
            productData.price = '0.00';
            productData.sku = '';
            productData.inventory_quantity = 0;
            productData.weight = '0';
            
            // Collect metafields data
            productData.metafields = collectMetafieldsData();
            
            // Add colour options to metafields
            if (productData.product_colours) {
                console.log('üîç Adding product_colours to metafields:', productData.product_colours);
                productData.metafields.push({
                    namespace: 'custom',
                    key: 'product_colours',
                    type: 'single_line_text_field',
                    value: productData.product_colours
                });
            }
            
            // Collect price data
            const priceData = collectPriceData();
            if (priceData.trade.length > 0) {
                productData.metafields.push({
                    namespace: 'custom',
                    key: 'pricejsontr',
                    type: 'single_line_text_field',
                    value: JSON.stringify(priceData.trade)
                });
            }
            if (priceData.endCustomer.length > 0) {
                productData.metafields.push({
                    namespace: 'custom',
                    key: 'pricejsoner',
                    type: 'single_line_text_field',
                    value: JSON.stringify(priceData.endCustomer)
                });
            }
            
            // Artwork: selected guideline saved as file_reference metafield
            if (selectedGuideline && selectedGuideline.id) {
                productData.metafields.push({
                    namespace: 'custom',
                    key: 'artworkguidelines',
                    type: 'file_reference',
                    value: selectedGuideline.id
                });
            }
            
            // Add product ID for updates
            if (isEditingProduct && selectedProduct) {
                productData.product_id = selectedProduct.id;
            }

            console.log('Submitting product data with metafields and price data:', productData);

            // Show loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('resultMessage').style.display = 'none';

            try {
                // Check if we have media files to upload or existing media to attach
                const hasMediaFiles = (selectedMediaFiles && selectedMediaFiles.length > 0) || (selectedShopifyMedia && selectedShopifyMedia.length > 0);
                
                // When editing, always use FormData to preserve existing media (even if no new media selected)
                const shouldUseFormData = hasMediaFiles || isEditingProduct;

                let response;
                if (shouldUseFormData) {
                    // Use FormData for file uploads or when editing to preserve media
                    const formData = new FormData();

                    // Add all product data as form fields
                    Object.keys(productData).forEach(key => {
                        if (key !== 'media_files') {
                            // Convert arrays and objects to JSON strings for FormData
                            if (key === 'metafields' && Array.isArray(productData[key])) {
                                formData.append(key, JSON.stringify(productData[key]));
                            } else if (key === 'colour_images' && typeof productData[key] === 'object') {
                                formData.append(key, JSON.stringify(productData[key]));
                            } else {
                                formData.append(key, productData[key]);
                            }
                        }
                    });
                    
                    // Before adding media, ensure we preserve existing images when editing
                    // BUT: Respect user's intentional removals - if images are already selected, 
                    // only merge in missing ones if the selection is empty (to handle initial load failures)
                    if (isEditingProduct) {
                        console.log(`üì∑ Re-fetching product images...`);
                        console.log(`üì∑ Current state: ${selectedMediaFiles.length} uploaded files, ${selectedShopifyMedia.length} Shopify media selected`);
                        try {
                            // Use the prices endpoint which includes images
                            const productResponse = await fetch(`/api/product/${selectedProduct.id}/prices`);
                            if (!productResponse.ok) {
                                throw new Error(`Failed to fetch product: ${productResponse.status}`);
                            }
                            const productData = await productResponse.json();
                            const existingImages = Array.isArray(productData.images) ? productData.images : [];
                            console.log(`üì∑ Found ${existingImages.length} existing images on product`);
                            console.log(`üì∑ All images from API:`, existingImages.map(img => ({id: img.id, src: img.src, position: img.position})));
                            
                            // Create a set of already-selected image IDs to avoid duplicates
                            const selectedIds = new Set(selectedShopifyMedia.map(m => String(m.id)));
                            console.log(`üì∑ Already have ${selectedIds.size} images in selectedShopifyMedia:`, Array.from(selectedIds));
                            
                            // Only add missing images if selection is empty (initial load failure scenario)
                            // If user has already made selections (including removals), respect their choices
                            if (selectedShopifyMedia.length === 0) {
                                console.log(`üì∑ No images selected - loading all existing images from product`);
                                let addedCount = 0;
                                existingImages.forEach(img => {
                                    // Use the same format as the main loading code
                                    let globalId = img.admin_graphql_api_id;
                                    if (!globalId) {
                                        const isImage = img.src && (img.src.includes('.jpg') || img.src.includes('.jpeg') || img.src.includes('.png') || img.src.includes('.gif') || img.src.includes('cdn.shopify.com'));
                                        globalId = isImage ? `gid://shopify/MediaImage/${img.id}` : `gid://shopify/GenericFile/${img.id}`;
                                    }
                                    
                                    selectedShopifyMedia.push({
                                        id: img.id,
                                        global_id: globalId,
                                        rest_api_id: img.id,
                                        url: img.src,
                                        filename: (img.alt || `image_${img.id}`),
                                        size: 0,
                                        is_image: true,
                                        content_type: 'image/jpeg'
                                    });
                                    addedCount++;
                                    console.log(`‚úÖ Added image to preserve: REST ID ${img.id}, Global ID ${globalId}`);
                                });
                                console.log(`‚úÖ Preserved ${selectedShopifyMedia.length} total images (added ${addedCount} new ones)`);
                            } else {
                                // User has made selections - respect them, don't add removed images back
                                console.log(`üì∑ User has ${selectedShopifyMedia.length} images selected - respecting their selection (not adding removed images back)`);
                                const existingImageIds = new Set(existingImages.map(img => String(img.id)));
                                const selectedButNotOnProduct = selectedShopifyMedia.filter(m => !existingImageIds.has(String(m.id)));
                                if (selectedButNotOnProduct.length > 0) {
                                    console.warn(`‚ö†Ô∏è ${selectedButNotOnProduct.length} selected images not found on product - they may have been deleted:`, selectedButNotOnProduct.map(m => m.id));
                                }
                            }
                        } catch (e) {
                            console.error('‚ùå Failed to fetch existing images for preservation:', e);
                            console.error('Full error details:', e);
                        }
                    }
                    
                    // Add media files (this preserves existing media when editing)
                    console.log(`üì¶ About to add media to form data...`);
                    console.log(`üì¶ selectedMediaFiles count: ${selectedMediaFiles.length}`);
                    console.log(`üì¶ selectedShopifyMedia count: ${selectedShopifyMedia.length}`);
                    console.log(`üì¶ selectedShopifyMedia IDs:`, selectedShopifyMedia.map(m => ({id: m.id, rest_api_id: m.rest_api_id || m.id})));
                    addMediaToFormData(formData);
                    
                    response = await fetch('/api/create-product', {
                        method: 'POST',
                        body: formData
                    });
                } else {
                    // Use JSON for regular requests
                    response = await fetch('/api/create-product', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(productData)
                    });
                }
                
                const result = await response.json();
                
                // Hide loading
                document.getElementById('loading').style.display = 'none';
                
                // Show result
                const resultDiv = document.getElementById('resultMessage');
                resultDiv.style.display = 'block';
                
                if (result.success) {
                    resultDiv.className = 'result-message result-success';
                    const actionText = isEditingProduct ? 'Updated' : 'Created';
                    const actionVerb = isEditingProduct ? 'updated' : 'created';
                    resultDiv.innerHTML = `
                        <h4><i class="fas fa-check-circle"></i> Product ${actionText} Successfully!</h4>
                        <p><strong>${result.product.title}</strong> has been ${actionVerb} in your Shopify store.</p>
                        <div class="product-link">
                            <strong>Product ID:</strong> ${result.product.id}<br>
                            <strong>Handle:</strong> ${result.product.handle}<br>
                            <a href="https://${result.product.admin_graphql_api_id.split('/').pop()}.myshopify.com/admin/products/${result.product.id}" target="_blank">
                            </a>
                        </div>
                    `;

                    // After creation: if artwork templates are staged, zip and save to metafield
                    try {
                        if (stagedArtworkTemplateFiles && stagedArtworkTemplateFiles.length > 0) {
                            const pid = result.product.id;
                            const title = result.product.title || 'Product';
                            await uploadArtworkTemplatesAfterCreate(pid, title);
                            // Clear staged list visuals
                            
                            stagedArtworkTemplateFiles = [];
                            const list = document.getElementById('artworkTemplatesList');
                            if (list) list.innerHTML = '<div class="muted">No files staged</div>';
                            // Append note
                            resultDiv.innerHTML += '<p></p>';
                        }
                    } catch (e) {
                        resultDiv.innerHTML += `<p style="color:#c0392b;">Artwork templates upload failed: ${e}</p>`;
                    }
                } else {
                    resultDiv.className = 'result-message result-error';
                    resultDiv.innerHTML = `
                        <h4><i class="fas fa-exclamation-triangle"></i> Error Creating Product</h4>
                        <p>${result.error}</p>
                    `;
                }
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                const resultDiv = document.getElementById('resultMessage');
                resultDiv.style.display = 'block';
                resultDiv.className = 'result-message result-error';
                resultDiv.innerHTML = `
                    <h4><i class="fas fa-exclamation-triangle"></i> Network Error</h4>
                    <p>Failed to create product: ${error.message}</p>
                `;
            }
        });

        // Custom Dropdown Functions
        function toggleDropdown(button) {
            const dropdown = button.closest('.custom-dropdown');
            const content = dropdown.querySelector('.dropdown-content');
            const isOpen = content.style.display !== 'none';
            
            // Close all other dropdowns
            document.querySelectorAll('.dropdown-content').forEach(dd => {
                dd.style.display = 'none';
                dd.closest('.custom-dropdown').querySelector('.dropdown-button').classList.remove('open');
            });
            
            // Toggle current dropdown
            if (isOpen) {
                content.style.display = 'none';
                button.classList.remove('open');
            } else {
                content.style.display = 'block';
                button.classList.add('open');
                
                // Options are already loaded on page load, no need to reload
            }
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.custom-dropdown')) {
                document.querySelectorAll('.dropdown-content').forEach(content => {
                    content.style.display = 'none';
                    content.closest('.custom-dropdown').querySelector('.dropdown-button').classList.remove('open');
                });
            }
        });
        
        function updateDropdownText(dropdown) {
            const checkboxes = dropdown.querySelectorAll('input[type="checkbox"]:checked');
            const textElement = dropdown.querySelector('.dropdown-text');
            
            if (checkboxes.length === 0) {
                const key = dropdown.dataset.key;
                textElement.textContent = key === 'custom_category' ? 'Select categories...' : 'Select subcategories...';
            } else if (checkboxes.length === 1) {
                textElement.textContent = checkboxes[0].nextElementSibling.textContent;
            } else {
                textElement.textContent = `${checkboxes.length} selected`;
            }
        }
        
        // Category and Subcategory Functions - Updated to work with custom dropdowns
        async function loadCategoryDropdownOptions(dropdown) {
            try {
                console.log('üîç Loading category options from API...');
                const response = await fetch('/api/metafield-choices/custom.custom_category');
                console.log('üì° Category API response status:', response.status);
                const data = await response.json();
                console.log('üìä Category API response data:', data);
                
                if (data.success && data.choices) {
                    const content = dropdown.querySelector('.dropdown-content');
                    content.innerHTML = '';
                    
                    // Add category options with checkboxes
                    data.choices.forEach((category, index) => {
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'dropdown-option';
                        const safeId = `cat_${index}_${category.replace(/[^a-zA-Z0-9]/g, '_')}`;
                        
                        // Create checkbox and label using DOM methods for proper escaping
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = safeId;
                        checkbox.value = category;  // DOM methods handle escaping automatically
                        
                        const label = document.createElement('label');
                        label.htmlFor = safeId;
                        label.textContent = category;
                        
                        optionDiv.appendChild(checkbox);
                        optionDiv.appendChild(label);
                        content.appendChild(optionDiv);
                        
                        // Add event listener to checkbox (use the variable we already created)
                        checkbox.addEventListener('change', function() {
                            updateDropdownText(dropdown);
                            console.log(`Category checkbox changed: ${category}, checked: ${this.checked}`);
                        });
                    });
                    console.log(`‚úÖ Successfully loaded ${data.choices.length} category options`);
                } else {
                    console.log('‚ùå Category API returned no data or failed');
                }
            } catch (error) {
                console.error('‚ùå Error loading categories:', error);
            }
        }

        async function loadSubcategoryDropdownOptions(dropdown) {
            try {
                console.log('üîç Loading subcategory options from API...');
                const response = await fetch('/api/metafield-choices/custom.subcategory');
                console.log('üì° Subcategory API response status:', response.status);
                const data = await response.json();
                console.log('üìä Subcategory API response data:', data);
                
                if (data.success && data.choices) {
                    const content = dropdown.querySelector('.dropdown-content');
                    content.innerHTML = '';
                    
                    // Add subcategory options with checkboxes
                    data.choices.forEach((subcategory, index) => {
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'dropdown-option';
                        const safeId = `sub_${index}_${subcategory.replace(/[^a-zA-Z0-9]/g, '_')}`;
                        
                        // Create checkbox and label using DOM methods for proper escaping
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = safeId;
                        checkbox.value = subcategory;  // DOM methods handle escaping automatically
                        
                        const label = document.createElement('label');
                        label.htmlFor = safeId;
                        label.textContent = subcategory;
                        
                        optionDiv.appendChild(checkbox);
                        optionDiv.appendChild(label);
                        content.appendChild(optionDiv);
                        
                        // Add event listener to checkbox (use the variable we already created)
                        checkbox.addEventListener('change', function() {
                            updateDropdownText(dropdown);
                            console.log(`Subcategory checkbox changed: ${subcategory}, checked: ${this.checked}`);
                        });
                    });
                    console.log(`‚úÖ Successfully loaded ${data.choices.length} subcategory options`);
                } else {
                    console.log('‚ùå Subcategory API returned no data or failed');
                }
            } catch (error) {
                console.error('‚ùå Error loading subcategories:', error);
            }
        }
        
        // Legacy functions for backward compatibility
        async function loadCategoryOptions() {
            // This function is kept for backward compatibility but does nothing
            // The new dropdown system handles loading automatically
        }
        
        async function loadSubcategoryOptions() {
            // This function is kept for backward compatibility but does nothing
            // The new dropdown system handles loading automatically
        }

        // Media Upload Functionality
        let selectedMediaFiles = [];
        const maxFiles = 250;

        // Initialize media upload functionality
        let pcAllProducts = [];
        document.addEventListener('DOMContentLoaded', async function() {
            const mediaUploadArea = document.getElementById('mediaUploadArea');
            const mediaFilesInput = document.getElementById('mediaFiles');
            const mediaPreviewContainer = document.getElementById('mediaPreviewContainer');

            // Click to upload
            mediaUploadArea.addEventListener('click', () => {
                mediaFilesInput.click();
            });

            // File input change
            mediaFilesInput.addEventListener('change', handleFileSelection);

            // Drag and drop functionality
            mediaUploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                mediaUploadArea.classList.add('dragover');
            });

            mediaUploadArea.addEventListener('dragleave', () => {
                mediaUploadArea.classList.remove('dragover');
            });

            mediaUploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                mediaUploadArea.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                handleFileSelection({ target: { files: files } });
            });

            // Load category and subcategory options
            loadCategoryOptions();
            loadSubcategoryOptions();

            // Load Shopify media on page load
            try { loadShopifyMedia(); } catch (e) { console.log('Load media on init failed'); }

            // Load products for search (cached)
            try {
                const resp = await fetch('/api/products');
                pcAllProducts = await resp.json();
            } catch (e) { pcAllProducts = []; }

            // Wire product search (copied behavior from Price Manager)
            const pcInput = document.getElementById('pc-product-input');
            const pcDrop = document.getElementById('pc-autocomplete-dropdown');
            let pcTimer;
            pcInput.addEventListener('input', function() {
                const q = this.value.trim().toLowerCase();
                clearTimeout(pcTimer);
                if (q.length < 2) {
                    pcHideAutocomplete();
                    // Hide versions panel when search is cleared
                    const versionsPanel = document.getElementById('pcVersionsPanel');
                    if (versionsPanel) versionsPanel.style.display = 'none';
                    return;
                }
                pcTimer = setTimeout(() => pcShowAutocomplete(q), 300);
            });
            pcInput.addEventListener('keypress', function(event){
                if (event.key === 'Enter') { event.preventDefault(); pcHideAutocomplete(); }
            });
            document.addEventListener('click', function(event){
                if (!pcInput.contains(event.target) && !pcDrop.contains(event.target)) { pcHideAutocomplete(); }
            });
        });

        function pcShowAutocomplete(query) {
            const pcDrop = document.getElementById('pc-autocomplete-dropdown');
            const matches = (pcAllProducts || []).filter(p => {
                const name = (p.title || '').toLowerCase();
                const id = String(p.id || '');
                const sku = ((p.variants && p.variants[0] && p.variants[0].sku) || '').toLowerCase();
                return name.includes(query) || id.includes(query) || sku.includes(query);
            }).slice(0, 20);
            if (!matches.length) { pcDrop.style.display = 'none'; return; }
            pcDrop.innerHTML = '';
            matches.forEach(p => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                const sku = (p.variants && p.variants[0] && p.variants[0].sku) || '';
                item.innerHTML = `<div class=\"product-name\">${p.title}</div><div class=\"product-id\">${sku}</div>`;
                item.onclick = () => pcPopulateFromProduct(p.id, p.title);
                pcDrop.appendChild(item);
            });
            pcDrop.style.display = 'block';
        }

        function pcHideAutocomplete(){
            const pcDrop = document.getElementById('pc-autocomplete-dropdown');
            pcDrop.style.display = 'none';
        }

        async function pcPopulateFromProduct(productId, title) {
            const pcInput = document.getElementById('pc-product-input');
            const pcDrop = document.getElementById('pc-autocomplete-dropdown');

            // Set editing mode
            isEditingProduct = true;
            selectedProduct = { id: productId, title: title };

            // Change button text to "Save Product"
            const submitBtn = document.querySelector('#productForm button[type="submit"]');
            if (submitBtn) {
                submitBtn.innerHTML = '<i class="fas fa-save"></i> Save Product';
            }

            // Show form sections when a product is selected
            showCreateForm();
            try {
                const resp = await fetch(`/api/product/${productId}/prices`);
                const data = await resp.json();
                if (!data || !data.id) throw new Error('Failed to load product');

                // Title
                const titleEl = document.getElementById('title');
                if (titleEl) titleEl.value = data.title || title || '';

                // Status (default to active if unknown)
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    const s = (data.status || 'active').toLowerCase();
                    statusEl.value = ['active','draft','archived'].includes(s) ? s : 'active';
                }

                // Description
                if (typeof data.body_html === 'string') {
                    const descEl = document.getElementById('description');
                    if (descEl) {
                        // Check if the HTML contains h3 headings (either format)
                        if (data.body_html.includes('<h3>')) {
                            // Preserve the HTML structure for h3 headings
                            descEl.value = data.body_html;
                            isHtmlMode = true;
                        } else {
                            // Convert HTML back to text for other HTML
                        descEl.value = htmlToText(data.body_html);
                            isHtmlMode = true;
                        }
                        updateConverterButton();
                    }
                }

                // Category/Subcategory from metafields
                const mfs = data.metafields || [];
                
                // Helper function to extract value from metafield (handles JSON array format)
                function extractMetafieldValue(metafield) {
                    if (!metafield || !metafield.value) return '';
                    
                    const value = metafield.value;
                    console.log('üîç Raw metafield value:', value, 'Type:', typeof value);
                    
                    // Handle different formats for list.single_line_text_field
                    try {
                        // Try to parse as JSON array (for list type metafields)
                        const parsed = JSON.parse(value);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            const result = parsed[0];
                            console.log('üîç Parsed JSON array, extracted:', result);
                            return result;
                        }
                    } catch (e) {
                        console.log('üîç Not JSON, treating as plain string');
                    }
                    
                    // If it's already a plain string, return it
                    console.log('üîç Returning plain string:', value);
                    return value;
                }
                
                const mfCatMetafield = mfs.find(m => m.namespace === 'custom' && m.key === 'custom_category');
                const mfSubMetafield = mfs.find(m => m.namespace === 'custom' && m.key === 'subcategory');
                
                console.log('üîç All metafields:', mfs);
                console.log('üîç Category metafield found:', mfCatMetafield);
                console.log('üîç Subcategory metafield found:', mfSubMetafield);
                
                const mfCat = extractMetafieldValue(mfCatMetafield);
                const mfSub = extractMetafieldValue(mfSubMetafield);

                // Ensure options are loaded, then set values
                await ensureCategoryOptionsLoaded();
                
                // Wait a bit more to ensure options are fully loaded
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // Find the metafield select elements by data-key attribute
                const catSel = document.querySelector('select[data-key="custom_category"]');
                const subSel = document.querySelector('select[data-key="subcategory"]');
                
                console.log('üîç Found category select element:', catSel);
                console.log('üîç Found subcategory select element:', subSel);
                console.log('üîç Category options count:', catSel ? catSel.options.length : 0);
                console.log('üîç Subcategory options count:', subSel ? subSel.options.length : 0);
                console.log('üîç Setting category value to:', mfCat);
                console.log('üîç Setting subcategory value to:', mfSub);
                
                if (catSel && mfCat) {
                    // Check if the option exists before setting
                    const optionExists = Array.from(catSel.options).some(option => option.value === mfCat);
                    console.log('üîç Category option exists:', optionExists);
                    if (optionExists) {
                        catSel.value = mfCat;
                        console.log('‚úÖ Category value set successfully');
                    } else {
                        console.log('‚ö†Ô∏è Category option not found, available options:', Array.from(catSel.options).map(o => o.value));
                    }
                }
                if (subSel && mfSub) {
                    // Check if the option exists before setting
                    const optionExists = Array.from(subSel.options).some(option => option.value === mfSub);
                    console.log('üîç Subcategory option exists:', optionExists);
                    if (optionExists) {
                        subSel.value = mfSub;
                        console.log('‚úÖ Subcategory value set successfully');
                    } else {
                        console.log('‚ö†Ô∏è Subcategory option not found, available options:', Array.from(subSel.options).map(o => o.value));
                    }
                }

                // Close dropdown and set input to selected title
                if (pcInput) pcInput.value = data.title || title || '';
                if (pcDrop) pcDrop.style.display = 'none';

                // Don't call displayMetafields again - it will overwrite our category/subcategory selections
                // The metafields are already displayed from loadMetafields(), we just need to populate their values
                console.log('üîç Skipping displayMetafields call to preserve category/subcategory selections');
                
                // Instead, populate individual metafield values without recreating the UI
                try {
                    populateMetafieldValues(mfs);
                } catch (e) { console.log('Populate metafield values failed', e); }
                
                // Handle color loading separately since we skipped displayMetafields
                try {
                    const coloursMetafield = mfs.find(m => m.key === 'product_colours' && m.namespace === 'custom');
                    if (coloursMetafield && coloursMetafield.value) {
                        console.log('üîç Loading colours from metafield:', coloursMetafield.value);
                        loadColoursIntoInputs(coloursMetafield.value);
                    } else {
                        console.log('üîç No product_colours metafield found, starting with empty inputs');
                        loadColoursIntoInputs('');
                    }
                } catch (e) { console.log('Color loading failed', e); }

                // Load price tables from metafields custom.pricejsontr and custom.pricejsoner if present
                try {
                    const trMf = (mfs.find(m => m.namespace === 'custom' && m.key === 'pricejsontr') || {}).value || '';
                    const erMf = (mfs.find(m => m.namespace === 'custom' && m.key === 'pricejsoner') || {}).value || '';
                    currentPriceData.trade = [];
                    currentPriceData.endCustomer = [];
                    if (trMf) {
                        try { 
                            const parsed = JSON.parse(trMf);
                            // Format all prices to 2 decimal places as strings
                            currentPriceData.trade = parsed.map(item => ({
                                min: item.min,
                                max: item.max,
                                price: parseFloat(parseFloat(item.price || 0)).toFixed(2)
                            }));
                        } catch {}
                    }
                    if (erMf) {
                        try { 
                            const parsed = JSON.parse(erMf);
                            // Format all prices to 2 decimal places as strings
                            currentPriceData.endCustomer = parsed.map(item => ({
                                min: item.min,
                                max: item.max,
                                price: parseFloat(parseFloat(item.price || 0)).toFixed(2)
                            }));
                        } catch {}
                    }
                    rebuildTable('trade-content', 'trade-table-body');
                    rebuildTable('end-customer-content', 'end-customer-table-body');
                    showEditableTable('trade-content');
                    showEditableTable('end-customer-content');
                } catch (e) { console.log('Price data load failed', e); }

                // Prefill media preview with Shopify images
                try {
                    // Don't clear selectedMediaFiles - those might be newly uploaded files that haven't been saved yet
                    // Only clear selectedShopifyMedia which will be repopulated from the product
                    selectedShopifyMedia = [];
                    console.log(`üì∑ Raw product data.images:`, data.images);
                    console.log(`üì∑ Type of data.images:`, typeof data.images, Array.isArray(data.images));
                    const media = Array.isArray(data.images) ? data.images : [];
                    console.log(`üì∑ Loading ${media.length} existing images for product ${productId}`);
                    console.log(`üì∑ Full images array:`, JSON.stringify(media, null, 2));
                    if (media.length === 0) {
                        console.warn(`‚ö†Ô∏è No images found in product data! This might indicate missing images or API issue.`);
                    }
                    media.slice(0, maxFiles).forEach((img, idx) => {
                        console.log(`üì∑ Processing image ${idx + 1}/${media.length}:`, {
                            id: img.id,
                            src: img.src,
                            alt: img.alt,
                            admin_graphql_api_id: img.admin_graphql_api_id,
                            position: img.position,
                            created_at: img.created_at
                        });
                        // For images, use MediaImage format; for videos, use Video format
                        // Try admin_graphql_api_id first, then construct the correct format
                        let globalId = img.admin_graphql_api_id;
                        if (!globalId) {
                            // If it's an image, use MediaImage; otherwise use GenericFile
                            // Check if src suggests it's an image (has image extension or is from shopify cdn)
                            const isImage = img.src && (img.src.includes('.jpg') || img.src.includes('.jpeg') || img.src.includes('.png') || img.src.includes('.gif') || img.src.includes('cdn.shopify.com'));
                            if (isImage) {
                                globalId = `gid://shopify/MediaImage/${img.id}`;
                            } else {
                                globalId = `gid://shopify/GenericFile/${img.id}`;
                            }
                        }
                        
                        const mediaItem = {
                            id: img.id,  // REST API numeric ID - this is what we need to preserve
                            global_id: globalId,  // GraphQL global ID - used for some operations
                            rest_api_id: img.id,  // Explicitly store REST API ID for backend comparison
                            url: img.src,
                            filename: (img.alt || `image_${img.id}`),
                            size: 0,
                            is_image: true,
                            content_type: 'image/jpeg'
                        };
                        selectedShopifyMedia.push(mediaItem);
                        console.log(`‚úÖ Added image to selectedShopifyMedia: REST ID ${img.id}, Global ID ${globalId}`);
                        });
                    console.log(`üì¶ Total images loaded into selectedShopifyMedia: ${selectedShopifyMedia.length}`);
                    updateMediaPreview();
                } catch (e) { 
                    console.error('‚ùå Media prefill failed', e); 
                    console.log('‚ö†Ô∏è Could not load existing media - images may be lost on save!');
                }

                // Reflect selected artwork guideline
                try {
                    const glMf = (mfs.find(m => m.namespace === 'custom' && m.key === 'artworkguidelines') || {}).value || '';
                    if (glMf) {
                        selectedGuideline = { id: glMf, name: '', column: '' };
                        // reset all buttons
                        document.querySelectorAll('.guideline-row .use-btn').forEach(btn => {
                            btn.classList.remove('btn-success');
                            btn.classList.add('btn-secondary');
                            btn.textContent = 'Use';
                        });
                        const row = Array.from(document.querySelectorAll('.guideline-row'))
                            .find(r => decodeURIComponent(r.getAttribute('data-gid')||'') === glMf);
                        if (row) {
                            const btn = row.querySelector('.use-btn');
                            if (btn) {
                                btn.classList.remove('btn-secondary');
                                btn.classList.add('btn-success');
                                btn.textContent = 'Selected';
                            }
                        }
                    }
                } catch (e) { console.log('Guideline reflect failed', e); }

                // Load product artwork templates like Templates Uploader
                try {
                    const atMf = (mfs.find(m => m.namespace === 'custom' && m.key === 'artworktemplates') || {}).value || '';
                    pcCurrentTemplatesFileGlobalId = atMf || '';
                    pcStagedRemoteEntries = [];
                    if (atMf) {
                        const respZip = await fetch('/api/templates-uploader/zip-contents', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ file_global_id: atMf })
                        });
                        const zipData = await respZip.json();
                        if (zipData && zipData.success) {
                            pcStagedRemoteEntries = (zipData.entries || []).map(it => ({ name: it.name, size: it.size, is_image: it.is_image }));
                        }
                        // Load versions list by scanning Shopify Files directly (mirror Templates Uploader behavior)
                        try {
                            const skuFromMf = (mfs.find(m => m.namespace==='custom' && m.key==='sku')||{}).value || '';
                            const variantSku = (Array.isArray(data.variants) && data.variants[0] && data.variants[0].sku) ? data.variants[0].sku : '';
                            const skuGuess = sanitizeBase(variantSku || skuFromMf || 'NOSKU');
                            await pcLoadVersionsDirect(atMf, skuGuess, sanitizeBase(data.title||title||'product'));
                        } catch (e) { console.log('Version list load failed', e); }
                    }
                    stageArtworkTemplates([]);
                } catch (e) { console.log('Templates prefill failed', e); }
            } catch (e) {
                console.log('Populate failed:', e);
            }
        }

        function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }
        
        // Populate metafield values without recreating the UI
        function populateMetafieldValues(metafields) {
            console.log('üîç populateMetafieldValues called with:', metafields.length, 'metafields');
            
            metafields.forEach(metafield => {
                const key = metafield.key;
                const namespace = metafield.namespace;
                let value = metafield.value || '';
                
                // Handle JSON array values for list type metafields (like category/subcategory)
                let parsedValues = [];
                if (metafield.type === 'list.single_line_text_field' && value.startsWith('[') && value.endsWith(']')) {
                    try {
                        const parsed = JSON.parse(value);
                        if (Array.isArray(parsed)) {
                            parsedValues = parsed;
                            console.log(`üîç Parsed ${key} values from JSON array:`, parsedValues);
                        }
                    } catch (e) {
                        console.log(`‚ö†Ô∏è Failed to parse JSON array for ${key}: ${value}`);
                    }
                }
                
                // Find the corresponding input element (including custom dropdowns)
                const input = document.querySelector(`[data-key="${key}"][data-namespace="${namespace}"]`);
                
                // Special handling for product_size field with 3 separate inputs
                if (key === 'product_size' && namespace === 'custom') {
                    const sizeParts = value.split('*').map(part => part.trim());
                    const length = sizeParts[0] || '';
                    const width = sizeParts[1] || '';
                    const height = sizeParts[2] || '';
                    
                    // Find the three separate input fields
                    const lengthField = document.querySelector(`[data-key="${key}"][data-namespace="${namespace}"][data-part="length"]`);
                    const widthField = document.querySelector(`[data-key="${key}"][data-namespace="${namespace}"][data-part="width"]`);
                    const heightField = document.querySelector(`[data-key="${key}"][data-namespace="${namespace}"][data-part="height"]`);
                    
                    if (lengthField) {
                        lengthField.value = length;
                        console.log(`‚úÖ Set ${key} length field to: ${length}`);
                    }
                    if (widthField) {
                        widthField.value = width;
                        console.log(`‚úÖ Set ${key} width field to: ${width}`);
                    }
                    if (heightField) {
                        heightField.value = height;
                        console.log(`‚úÖ Set ${key} height field to: ${height}`);
                    }
                } else if (input) {
                    if (input.classList.contains('emoji-field-container')) {
                        // For emoji field containers, set the selected button
                        const allButtons = input.querySelectorAll('.emoji-btn');
                        allButtons.forEach(btn => btn.classList.remove('selected'));
                        
                        const selectedButton = input.querySelector(`[data-emoji="${value}"]`);
                        if (selectedButton) {
                            selectedButton.classList.add('selected');
                            input.dataset.selectedValue = value;
                            console.log(`‚úÖ Set ${key} emoji field to: ${value}`);
                        }
                    } else if (input.classList.contains('custom-dropdown')) {
                        // For custom dropdowns, set checkbox selections
                        if (key === 'custom_category' || key === 'subcategory') {
                            // Clear all checkboxes first
                            const checkboxes = input.querySelectorAll('input[type="checkbox"]');
                            checkboxes.forEach(checkbox => checkbox.checked = false);
                            
                            // Set multiple selections if we have parsed values
                            if (parsedValues.length > 0) {
                                // Get all checkboxes first for efficient lookup
                                const allCheckboxes = input.querySelectorAll('input[type="checkbox"]');
                                
                                parsedValues.forEach(val => {
                                    const trimmedVal = val.trim();
                                    // Try to find checkbox by exact value match (most reliable)
                                    let found = false;
                                    allCheckboxes.forEach(cb => {
                                        if (cb.value.trim() === trimmedVal) {
                                            cb.checked = true;
                                            found = true;
                                            console.log(`‚úÖ Checked checkbox for ${key}: "${trimmedVal}"`);
                                        }
                                    });
                                    
                                    if (!found) {
                                        console.warn(`‚ö†Ô∏è Could not find checkbox for ${key} with value: "${trimmedVal}"`);
                                        // Try to find by text content as fallback
                                        allCheckboxes.forEach(cb => {
                                            const label = cb.closest('.dropdown-option')?.querySelector('label');
                                            if (label && label.textContent.trim() === trimmedVal) {
                                                cb.checked = true;
                                                console.log(`‚úÖ Found checkbox by text match for ${key}: "${trimmedVal}"`);
                                            }
                                        });
                                    }
                                });
                                updateDropdownText(input);
                                console.log(`‚úÖ Set ${key} custom dropdown values to:`, parsedValues);
                            } else {
                                // Fallback to single value
                                const trimmedValue = value.trim();
                                const allCheckboxes = input.querySelectorAll('input[type="checkbox"]');
                                let found = false;
                                allCheckboxes.forEach(cb => {
                                    if (cb.value.trim() === trimmedValue) {
                                        cb.checked = true;
                                        found = true;
                                    }
                                });
                                if (!found) {
                                    // Try by label text as fallback
                                    allCheckboxes.forEach(cb => {
                                        const label = cb.closest('.dropdown-option')?.querySelector('label');
                                        if (label && label.textContent.trim() === trimmedValue) {
                                            cb.checked = true;
                                        }
                                    });
                                }
                                updateDropdownText(input);
                                console.log(`‚úÖ Set ${key} custom dropdown value to: ${trimmedValue}`);
                            }
                        }
                    } else if (input.tagName === 'SELECT') {
                        // For select elements, handle multi-select for category/subcategory
                        if (key === 'custom_category' || key === 'subcategory') {
                            // Clear all selections first
                            Array.from(input.options).forEach(option => option.selected = false);
                            
                            // Set multiple selections if we have parsed values
                            if (parsedValues.length > 0) {
                                parsedValues.forEach(val => {
                                    const option = Array.from(input.options).find(opt => opt.value === val);
                                    if (option) {
                                        option.selected = true;
                                    }
                                });
                                console.log(`‚úÖ Set ${key} multi-select values to:`, parsedValues);
                            } else {
                                // Fallback to single value
                                input.value = value;
                                console.log(`‚úÖ Set ${key} select value to: ${value}`);
                            }
                        } else {
                            // For regular select elements, set the value
                            input.value = value;
                            console.log(`‚úÖ Set ${key} select value to: ${value}`);
                        }
                    } else if (input.tagName === 'TEXTAREA') {
                        // For textarea elements, set the value
                        input.value = value;
                        console.log(`‚úÖ Set ${key} textarea value to: ${value}`);
                    } else if (input.tagName === 'INPUT') {
                        // For input elements, set the value
                        input.value = value;
                        console.log(`‚úÖ Set ${key} input value to: ${value}`);
                    }
                } else {
                    console.log(`‚ö†Ô∏è No input found for metafield: ${namespace}:${key}`);
                }
            });
        }
        async function ensureCategoryOptionsLoaded(){
            // Trigger loads if not populated
            await Promise.resolve();
            try { await loadCategoryOptions(); } catch(e){}
            try { await loadSubcategoryOptions(); } catch(e){}
            const maxWait = 20; // ~2s
            for (let i=0;i<maxWait;i++){
                const catSel = document.querySelector('select[data-key="custom_category"]');
                const subSel = document.querySelector('select[data-key="subcategory"]');
                console.log(`üîç Wait attempt ${i+1}: Category options: ${catSel ? catSel.options.length : 0}, Subcategory options: ${subSel ? subSel.options.length : 0}`);
                if (catSel && catSel.options && catSel.options.length>1 && subSel && subSel.options && subSel.options.length>1){
                    console.log('‚úÖ Category options loaded successfully');
                    return;
                }
                await wait(100);
            }
            console.log('‚ö†Ô∏è Category options loading timeout reached');
        }

        // Match Templates Uploader utility
        function bytesToSize(bytes) {
            if (!bytes) return '0 B';
            const sizes = ['B','KB','MB','GB'];
            const i = Math.floor(Math.log(bytes)/Math.log(1024));
            return (bytes/Math.pow(1024,i)).toFixed(1)+' '+sizes[i];
        }

        function renderPcVersionsHeader() {
            const panel = document.getElementById('pcVersionsPanel');
            if (!panel) return;
            panel.style.display = 'block';
            if (!panel.getAttribute('data-init')) {
                panel.setAttribute('data-init', '1');
            }
        }

        async function pcRenderVersionsFromForm() {
            try {
                const panel = document.getElementById('pcVersionsPanel');
                if (!panel) return;
                const skuInput = document.querySelector('.metafield-value[data-namespace="custom"][data-key="sku"]');
                const titleInput = document.getElementById('title');
                const skuVal = sanitizeBase((skuInput && skuInput.value) ? skuInput.value : 'NOSKU');
                const titleVal = sanitizeBase((titleInput && titleInput.value) ? titleInput.value : 'product');
                // Only render if we have at least a title
                const baseName = `${skuVal}_${titleVal}_artwork_templates`;
                // Show the panel first
                renderPcVersionsHeader();
                // Attempt server-driven versions list first, fall back to direct scan
                try {
                    await renderPcVersionsList(baseName, pcCurrentTemplatesFileGlobalId || '');
                } catch (apiError) {
                    console.log('API versions failed, falling back to direct scan:', apiError);
                    await pcLoadVersionsDirect(pcCurrentTemplatesFileGlobalId || '', skuVal, titleVal);
                }
            } catch (e) { console.log('Versions render failed:', e); }
        }

        async function renderPcVersionsList(baseName, currentGlobalId) {
            const panel = document.getElementById('pcVersionsPanel');
            if (!panel) return;
            try {
                const res = await fetch(`/api/templates-uploader/versions?base=${encodeURIComponent(baseName)}`);
                const data = await res.json();
                if (!data.success) {
                    panel.style.display = 'block';
                    panel.innerHTML = `<div class=\"danger\">${data.error || 'Could not load versions'}</div>`;
                    return;
                }
                const versions = Array.isArray(data.versions) ? data.versions : [];
                let currentId = currentGlobalId || '';
                try {
                    const mf = (await (await fetch(`/api/product/${selectedProduct?.id}/prices`)).json()).metafields || [];
                    const cmf = (mf.find(m => m.namespace==='custom' && m.key==='artworktemplates')||{}).value || '';
                    if (cmf) currentId = cmf;
                } catch {}
                // Build HTML exactly like Templates Uploader
                const rows = versions.map(v => {
                    const isCurrent = currentId && v.global_id && String(v.global_id) === String(currentId);
                    const badge = isCurrent ? '<span style="margin-left:8px;padding:2px 6px;border-radius:6px;background:#e6f4ea;color:#1f7a1f;font-size:12px;">In use</span>' : '';
                    const saveBtn = isCurrent ? '' : `<a href=\"#\" title=\"Save to product\" onclick=\"pcUseVersion('${v.global_id}')\" style=\"color:#28a745;margin-left:10px;\"><i class=\"fas fa-save\"></i></a>`;
                    const download = `<a href=\"${v.url || '#'}\" download title=\"Download\" style=\"color:#667eea;margin-left:auto;\"><i class=\"fas fa-download\"></i></a>`;
                    const cid = `pc_ver_contents_${v.version}`;
                    const toggle = `<button type=\"button\" title=\"Toggle contents\" onclick=\"pcToggleVersionContents('${cid}','${v.global_id}', this)\" style=\"background:none;border:none;cursor:pointer;color:#555;\"><i class=\"fas fa-chevron-right\"></i></button>`;
                    return `<div style=\"margin:4px 0;\">\n                        <div style=\"display:flex;align-items:center;gap:10px;\">\n                            ${toggle}\n                            <div class=\"muted\">v${v.version}</div>\n                            <div style=\"flex:1;\">${v.name}${badge}</div>\n                            ${saveBtn}${download}\n                        </div>\n                        <div id=\"${cid}\" class=\"mf\" style=\"margin-top:6px; display:none;\"></div>\n                    </div>`;
                }).join('');
                panel.style.display = 'block';
                panel.innerHTML = '<div style="font-weight:600;margin-bottom:8px;">All Versions</div>' + (versions.length ? rows : '<div class="muted">No previous versions</div>');
            } catch (e) {
                panel.innerHTML = `<div class=\"danger\">${e}</div>`;
            }
        }

        // Fully re-implemented: scan Shopify Files and compute versions client-side (fallback)
        async function pcLoadVersionsDirect(currentGlobalId, sku, titleBase) {
            const panel = document.getElementById('pcVersionsPanel');
            if (!panel) return;
            try {
                const res = await fetch('/api/shopify/files');
                const files = await res.json();
                const base = `${sku}_${titleBase}_artwork_templates`;
                const re = new RegExp(`^${base.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}_(\\d+)\\.zip$`, 'i');
                const versions = [];
                for (const f of (files || [])) {
                    let name = f.filename || f.alt || '';
                    if (!name) {
                        const url = f.url || '';
                        if (url) name = url.split('/').pop().split('?')[0];
                    }
                    const m = name && name.match(re);
                    if (m) {
                        versions.push({
                            name,
                            version: parseInt(m[1], 10) || 0,
                            url: f.url || '',
                            global_id: f.original_global_id || ''
                        });
                    }
                }
                versions.sort((a,b) => (b.version||0) - (a.version||0));
                let currentId = currentGlobalId || '';
                try {
                    const mf = (await (await fetch(`/api/product/${selectedProduct?.id}/prices`)).json()).metafields || [];
                    const cmf = (mf.find(m => m.namespace==='custom' && m.key==='artworktemplates')||{}).value || '';
                    if (cmf) currentId = cmf;
                } catch {}
                const rows = versions.map(v => {
                    const isCurrent = currentId && v.global_id && String(v.global_id) === String(currentId);
                    const badge = isCurrent ? '<span style="margin-left:8px;padding:2px 6px;border-radius:6px;background:#e6f4ea;color:#1f7a1f;font-size:12px;">In use</span>' : '';
                    const saveBtn = isCurrent ? '' : `<a href=\"#\" title=\"Save to product\" onclick=\"pcUseVersion('${v.global_id}')\" style=\"color:#28a745;margin-left:10px;\"><i class=\"fas fa-save\"></i></a>`;
                    const download = `<a href=\"${v.url || '#'}\" download title=\"Download\" style=\"color:#667eea;margin-left:auto;\"><i class=\"fas fa-download\"></i></a>`;
                    const cid = `pc_ver_contents_${v.version}`;
                    const toggle = `<button type=\"button\" title=\"Toggle contents\" onclick=\"pcToggleVersionContents('${cid}','${v.global_id}', this)\" style=\"background:none;border:none;cursor:pointer;color:#555;\"><i class=\"fas fa-chevron-right\"></i></button>`;
                    return `<div style=\"margin:4px 0;\">\n                        <div style=\"display:flex;align-items:center;gap:10px;\">\n                            ${toggle}\n                            <div class=\"muted\">v${v.version}</div>\n                            <div style=\"flex:1;\">${v.name}${badge}</div>\n                            ${saveBtn}${download}\n                        </div>\n                        <div id=\"${cid}\" class=\"mf\" style=\"margin-top:6px; display:none;\"></div>\n                    </div>`;
                }).join('');
                panel.style.display = 'block';
                panel.innerHTML = '<div style="font-weight:600;margin-bottom:8px;">All Versions</div>' + (versions.length ? rows : '<div class="muted">No previous versions</div>');
            } catch (e) {
                panel.style.display = 'block';
                panel.innerHTML = `<div class=\"danger\">${e}</div>`;
            }
        }

        async function pcUseVersion(globalId) {
            try {
                if (!selectedProduct) return;
                const res = await fetch('/api/templates-uploader/use-version', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ product_id: selectedProduct.id, file_global_id: globalId })
                });
                const data = await res.json();
                if (data && data.success) {
                    const respZip = await fetch('/api/templates-uploader/zip-contents', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ file_global_id: globalId })});
                    const zipData = await respZip.json();
                    if (zipData.success) {
                        pcCurrentTemplatesFileGlobalId = globalId;
                        stagedArtworkTemplateFiles = [];
                        pcStagedRemoteEntries = (zipData.entries || []).map(it => ({ name: it.name, size: it.size, is_image: it.is_image }));
                        stageArtworkTemplates([]);
                        const skuResp = await fetch(`/api/product/${selectedProduct?.id}/prices`);
                        const skuData = await skuResp.json();
                        const mf = skuData.metafields || [];
                        const skuFromMf = (mf.find(m => m.namespace==='custom' && m.key==='sku')||{}).value || '';
                        const variantSku = (Array.isArray(selectedProduct?.variants) && selectedProduct.variants[0] && selectedProduct.variants[0].sku) ? selectedProduct.variants[0].sku : '';
                        const skuVal = sanitizeBase(skuFromMf || variantSku || 'NOSKU');
                        const baseName = `${skuVal}_${sanitizeBase(selectedProduct.title||'product')}_artwork_templates`;
                        await renderPcVersionsList(baseName, globalId);
                    }
                }
            } catch (e) { /* ignore */ }
        }

        async function pcToggleVersionContents(containerId, globalId, el) {
            const container = document.getElementById(containerId);
            if (!container) return;
            const icon = el && el.querySelector ? el.querySelector('i') : null;
            const isVisible = container.style.display !== 'none';
            if (isVisible && container.getAttribute('data-loaded') === 'true') {
                container.style.display = 'none';
                if (icon) { icon.classList.remove('fa-chevron-down'); icon.classList.add('fa-chevron-right'); }
                return;
            }
            if (container.getAttribute('data-loaded') === 'true') {
                container.style.display = 'block';
                if (icon) { icon.classList.remove('fa-chevron-right'); icon.classList.add('fa-chevron-down'); }
                return;
            }
            container.style.display = 'block';
            if (icon) { icon.classList.remove('fa-chevron-right'); icon.classList.add('fa-chevron-down'); }
            container.innerHTML = '<div class="muted">Loading‚Ä¶</div>';
            try {
                const resp = await fetch('/api/templates-uploader/zip-contents', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file_global_id: globalId })
                });
                const data = await resp.json();
                if (data.success) {
                    const entries = data.entries || [];
                    if (!entries.length) {
                        container.innerHTML = '<div class="muted">ZIP is empty</div>';
                    } else {
                        container.innerHTML = entries.map(it => {
                            const name = it.name;
                            const size = (it.size||0);
                            const sz = bytesToSize(size);
                            const viewUrl = `/api/templates-uploader/zip-file?file_global_id=${encodeURIComponent(globalId)}&name=${encodeURIComponent(name)}`;
                            const eye = `<a href=\"${viewUrl}\" target=\"_blank\" rel=\"noopener\" title=\"Open in new tab\" style=\"color:#667eea;\"><i class=\"fas fa-eye\"></i></a>`;
                            if (it.is_image && it.preview) {
                                return `<div style=\"display:flex;align-items:center;gap:10px;margin:4px 0;\"><img src=\"${it.preview}\" alt=\"${name}\" style=\"width:40px;height:40px;object-fit:cover;border-radius:6px;border:1px solid #eee;\"/><div style=\"flex:1;\"><div>${name}</div><div class=\"muted\">${sz}</div></div>${eye}</div>`;
                            }
                            return `<div style=\"display:flex;align-items:center;gap:10px;margin:4px 0;\"><div style=\"width:40px;height:40px;border:1px dashed #ccc;border-radius:6px;display:flex;align-items:center;justify-content:center;color:#999;\"><i class=\"fas fa-file\"></i></div><div style=\"flex:1;\"><div>${name}</div><div class=\"muted\">${sz}</div></div>${eye}</div>`;
                        }).join('');
                    }
                    container.setAttribute('data-loaded', 'true');
                } else {
                    container.innerHTML = `<div class=\"danger\">${data.error || 'Could not load contents'}</div>`;
                }
            } catch (e) {
                container.innerHTML = `<div class=\"danger\">${e}</div>`;
            }
        }

        function handleFileSelection(event) {
            const files = Array.from(event.target.files);
            const validFiles = files.filter(file => {
                const isValidType = file.type.startsWith('image/') || file.type.startsWith('video/');
                const isValidSize = file.size <= 100 * 1024 * 1024; // 100MB limit per file
                return isValidType && isValidSize;
            });

            if (validFiles.length !== files.length) {
                alert('Some files were skipped. Only images and videos under 100MB are allowed.');
            }

            // Check total file limit
            if (selectedMediaFiles.length + validFiles.length > maxFiles) {
                alert(`Maximum ${maxFiles} files allowed. You can only add ${maxFiles - selectedMediaFiles.length} more files.`);
                return;
            }

            // Add new files to selection
            selectedMediaFiles = selectedMediaFiles.concat(validFiles);
            updateMediaPreview();
        }

        // Note: updateMediaPreview is defined later with full Shopify media support

        function createMediaPreview(file, index, source = 'uploaded') {
            const previewItem = document.createElement('div');
            previewItem.className = 'media-preview-item';
            previewItem.draggable = true;
            previewItem.dataset.index = index;
            previewItem.dataset.type = 'uploaded';

            const isVideo = file.type.startsWith('video/');
            const mediaType = isVideo ? 'video' : 'image';
            const mediaTypeClass = isVideo ? 'video' : 'image';

            previewItem.innerHTML = `
                <div class="drag-handle" title="Drag to reorder">
                    <i class="fas fa-grip-vertical"></i>
                    <span>${index + 1}</span>
                </div>
                <div class="media-type ${mediaTypeClass}">${mediaType.toUpperCase()}</div>
                <button class="remove-media" title="Remove file">
                    <i class="fas fa-times"></i>
                </button>
                ${isVideo ? 
                    `<video><source src="${URL.createObjectURL(file)}" type="${file.type}"></video>` :
                    `<img src="${URL.createObjectURL(file)}" alt="${file.name}">`
                }
                <div class="media-info">
                    <div class="media-name" title="${file.name}">${file.name}</div>
                    <div class="media-size">${formatFileSize(file.size)}</div>
                </div>
            `;

            // Add remove button event listener
            const removeBtn = previewItem.querySelector('.remove-media');
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                // Store file reference for comparison
                const fileToRemove = file;
                console.log(`üóëÔ∏è Remove button clicked for uploaded file: ${fileToRemove.name}`);
                console.log(`üìã Current selectedMediaFiles before removal: ${selectedMediaFiles.length} files`);
                
                // Find and remove by file reference (more reliable than index)
                const indexToRemove = selectedMediaFiles.findIndex(f => f === fileToRemove);
                
                if (indexToRemove !== -1) {
                    selectedMediaFiles.splice(indexToRemove, 1);
                    console.log(`‚úÖ Removed uploaded file: ${fileToRemove.name}, Index was ${indexToRemove}`);
                    console.log(`üìã selectedMediaFiles after removal: ${selectedMediaFiles.length} files`);
                } else {
                    console.error(`‚ùå Could not find file ${fileToRemove.name} in selectedMediaFiles array!`);
                }
                
                updateMediaPreview();
            });

            // Add drag and drop event listeners
            addDragAndDropListeners(previewItem);

            return previewItem;
        }

        function removeMediaFile(index) {
            selectedMediaFiles.splice(index, 1);
            updateMediaPreview();
        }

        function clearAllMedia() {
            if (selectedMediaFiles.length > 0 && confirm('Are you sure you want to remove all selected media files?')) {
                selectedMediaFiles = [];
                updateMediaPreview();
                document.getElementById('mediaFiles').value = '';
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Simplified Drag and Drop Reordering Functions
        let draggedElement = null;
        let draggedIndex = null;

        function addDragAndDropListeners(element) {
            element.addEventListener('dragstart', handleDragStart);
            element.addEventListener('dragend', handleDragEnd);
            element.addEventListener('dragover', handleDragOver);
            element.addEventListener('dragenter', handleDragEnter);
            element.addEventListener('dragleave', handleDragLeave);
            element.addEventListener('drop', handleDrop);
        }

        function handleDragStart(e) {
            draggedElement = this;
            draggedIndex = parseInt(this.dataset.index);
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            draggedElement = null;
            draggedIndex = null;
            
            // Remove drag-over class from all elements
            document.querySelectorAll('.media-preview-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            if (this !== draggedElement) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
            
            if (this === draggedElement) {
                return;
            }
            
            const dropIndex = parseInt(this.dataset.index);
            const draggedType = draggedElement.dataset.type;
            const dropType = this.dataset.type;
            
            // Create combined array for reordering
            const allMedia = [
                ...selectedMediaFiles.map((file, i) => ({ type: 'uploaded', item: file, originalIndex: i })),
                ...selectedShopifyMedia.map((media, i) => ({ type: 'shopify', item: media, originalIndex: i }))
            ];
            
            // Perform the reorder
            const draggedItem = allMedia[draggedIndex];
            allMedia.splice(draggedIndex, 1);
            allMedia.splice(dropIndex, 0, draggedItem);
            
            // Separate back into the two arrays
            selectedMediaFiles = [];
            selectedShopifyMedia = [];
            
            allMedia.forEach(mediaItem => {
                if (mediaItem.type === 'uploaded') {
                    selectedMediaFiles.push(mediaItem.item);
                } else {
                    selectedShopifyMedia.push(mediaItem.item);
                }
            });
            
            // Update the preview to reflect the new order
            updateMediaPreview();
        }

        // Note: addMediaToFormData is defined later with full Shopify media support

        // Media Tab Switching
        function switchMediaTab(tab) {
            const uploadTab = document.getElementById('uploadTab');
            const selectTab = document.getElementById('selectTab');
            const uploadContent = document.getElementById('uploadTabContent');
            const selectContent = document.getElementById('selectTabContent');
            
            if (tab === 'upload') {
                uploadTab.classList.add('active');
                selectTab.classList.remove('active');
                uploadContent.style.display = 'block';
                selectContent.style.display = 'none';
            } else {
                selectTab.classList.add('active');
                uploadTab.classList.remove('active');
                selectContent.style.display = 'block';
                uploadContent.style.display = 'none';
            }
        }

        // Shopify Media Selection
        let shopifyMediaFiles = [];
        let selectedShopifyMedia = [];

        function loadShopifyMedia() {
            const grid = document.getElementById('shopifyMediaGrid');
            grid.innerHTML = '<div class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i><p>Loading Shopify media files...</p></div>';
            
            fetch('/api/shopify-media')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        shopifyMediaFiles = data.media_files;
                        displayShopifyMedia(shopifyMediaFiles);
                    } else {
                        grid.innerHTML = '<div class="loading-placeholder"><i class="fas fa-exclamation-triangle"></i><p>Error loading media files: ' + data.error + '</p></div>';
                    }
                })
                .catch(error => {
                    grid.innerHTML = '<div class="loading-placeholder"><i class="fas fa-exclamation-triangle"></i><p>Error loading media files: ' + error.message + '</p></div>';
                });
        }

        function displayShopifyMedia(mediaFiles) {
            const grid = document.getElementById('shopifyMediaGrid');
            
            if (mediaFiles.length === 0) {
                grid.innerHTML = '<div class="loading-placeholder"><i class="fas fa-folder-open"></i><p>No media files found in your Shopify store</p></div>';
                return;
            }
            
            grid.innerHTML = '';
            mediaFiles.forEach(media => {
                const mediaItem = document.createElement('div');
                mediaItem.className = 'shopify-media-item';
                mediaItem.onclick = () => toggleShopifyMediaSelection(media);
                
                const typeBadge = media.is_image ? 'IMG' : 'VID';
                const mediaElement = media.is_image ? 
                    `<img src="${media.url}" alt="${media.filename}" loading="lazy">` :
                    `<video><source src="${media.url}" type="${media.content_type}"></video>`;
                
                mediaItem.innerHTML = `
                    ${mediaElement}
                    <div class="shopify-media-type">${typeBadge}</div>
                    <div class="shopify-media-info">
                        <div class="shopify-media-filename">${media.filename}</div>
                        <div class="shopify-media-meta">${formatFileSize(media.size)} ‚Ä¢ ${new Date(media.created_at).toLocaleDateString()}</div>
                    </div>
                `;
                
                grid.appendChild(mediaItem);
            });
        }

        function toggleShopifyMediaSelection(media) {
            const index = selectedShopifyMedia.findIndex(m => m.id === media.id);
            
            if (index > -1) {
                // Remove from selection
                selectedShopifyMedia.splice(index, 1);
            } else {
                // Add to selection (check max files limit)
                if (selectedMediaFiles.length + selectedShopifyMedia.length >= maxFiles) {
                    alert(`Maximum ${maxFiles} files allowed. You can only add ${maxFiles - selectedMediaFiles.length - selectedShopifyMedia.length} more files.`);
                    return;
                }
                selectedShopifyMedia.push(media);
            }
            
            // Update UI
            updateShopifyMediaSelection();
            updateMediaPreview();
        }

        function updateShopifyMediaSelection() {
            const items = document.querySelectorAll('.shopify-media-item');
            items.forEach(item => {
                const filename = item.querySelector('.shopify-media-filename').textContent;
                const media = shopifyMediaFiles.find(m => m.filename === filename);
                
                if (selectedShopifyMedia.find(m => m.id === media.id)) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        function filterShopifyMedia() {
            const searchTerm = document.getElementById('mediaSearchInput').value.toLowerCase();
            const filteredMedia = shopifyMediaFiles.filter(media => 
                media.filename.toLowerCase().includes(searchTerm)
            );
            displayShopifyMedia(filteredMedia);
            updateShopifyMediaSelection();
        }

        function updateMediaPreview() {
            const totalFiles = selectedMediaFiles.length + selectedShopifyMedia.length;
            const mediaPreviewContainer = document.getElementById('mediaPreviewContainer');
            const mediaCount = document.querySelector('.media-count');
            const mediaPreviewGrid = document.getElementById('mediaPreviewGrid');
            
            if (totalFiles === 0) {
                mediaPreviewContainer.style.display = 'none';
                return;
            }
            
            mediaPreviewContainer.style.display = 'block';
            mediaCount.textContent = `${totalFiles} file${totalFiles !== 1 ? 's' : ''} selected`;
            
            // Clear existing previews
            mediaPreviewGrid.innerHTML = '';
            
            // Add uploaded files
            selectedMediaFiles.forEach((file, index) => {
                const preview = createMediaPreview(file, index, 'uploaded');
                mediaPreviewGrid.appendChild(preview);
            });
            
            // Add selected Shopify media
            selectedShopifyMedia.forEach((media, index) => {
                const preview = createShopifyMediaPreview(media, selectedMediaFiles.length + index);
                mediaPreviewGrid.appendChild(preview);
            });
        }

        function createShopifyMediaPreview(media, index) {
            const preview = document.createElement('div');
            preview.className = 'media-preview-item';
            preview.draggable = true;
            preview.dataset.index = index;
            preview.dataset.type = 'shopify';
            preview.dataset.mediaId = media.id;
            
            const typeIcon = media.is_image ? 'fas fa-image' : 'fas fa-video';
            const mediaElement = media.is_image ? 
                `<img src="${media.url}" alt="${media.filename}">` :
                `<video><source src="${media.url}" type="${media.content_type}"></video>`;
            
            preview.innerHTML = `
                <div class="drag-handle">
                    <i class="fas fa-grip-vertical"></i>
                    <span>${index + 1}</span>
                </div>
                ${mediaElement}
                <div class="media-info">
                    <div class="media-filename">${media.filename}</div>
                    <div class="media-meta">${formatFileSize(media.size)} ‚Ä¢ Shopify</div>
                </div>
                <div class="media-type">
                    <i class="${typeIcon}"></i>
                </div>
                <button class="remove-media" title="Remove file">
                    <i class="fas fa-times"></i>
                </button>
            `;
            
            // Add remove button event listener
            const removeBtn = preview.querySelector('.remove-media');
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                // Find the media by ID instead of index (more reliable)
                const mediaIdToRemove = media.id;
                const mediaIdToRemoveStr = String(mediaIdToRemove);
                
                console.log(`üóëÔ∏è Remove button clicked for Shopify media ID: ${mediaIdToRemoveStr}`);
                console.log(`üìã Current selectedShopifyMedia before removal:`, selectedShopifyMedia.map(m => ({id: m.id, rest_id: m.rest_api_id})));
                
                // Find and remove by ID (check both id and rest_api_id)
                const indexToRemove = selectedShopifyMedia.findIndex(m => {
                    return String(m.id) === mediaIdToRemoveStr || 
                           String(m.rest_api_id || m.id) === mediaIdToRemoveStr;
                });
                
                if (indexToRemove !== -1) {
                    const removedMedia = selectedShopifyMedia[indexToRemove];
                    selectedShopifyMedia.splice(indexToRemove, 1);
                    console.log(`‚úÖ Removed Shopify media: ID ${mediaIdToRemoveStr}, Index was ${indexToRemove}`);
                    console.log(`üìã selectedShopifyMedia after removal (${selectedShopifyMedia.length} items):`, selectedShopifyMedia.map(m => ({id: m.id, rest_id: m.rest_api_id})));
                } else {
                    console.error(`‚ùå Could not find media ID ${mediaIdToRemoveStr} in selectedShopifyMedia array!`);
                    console.log(`üìã Array contents:`, selectedShopifyMedia.map(m => ({id: m.id, rest_id: m.rest_api_id})));
                }
                
                updateMediaPreview();
            });
            
            // Add drag and drop event listeners
            addDragAndDropListeners(preview);
            
            return preview;
        }

        function removeShopifyMedia(index) {
            selectedShopifyMedia.splice(index, 1);
            updateMediaPreview();
        }

        function clearAllMedia() {
            if (selectedMediaFiles.length + selectedShopifyMedia.length > 0 && confirm('Are you sure you want to remove all selected media files?')) {
                selectedMediaFiles = [];
                selectedShopifyMedia = [];
                updateMediaPreview();
                updateShopifyMediaSelection();
            }
        }

        // Update the addMediaToFormData function to handle both types
        function addMediaToFormData(formData) {
            // Build the complete media order combining both uploaded files and Shopify media
            // Position starts from 1 (Shopify's position numbering)
            const mediaOrder = [];
            let currentPosition = 1;
            
            // First, add uploaded files in order
            selectedMediaFiles.forEach((file, index) => {
                formData.append('media_files', file);
                mediaOrder.push({ type: 'upload', index: index, position: currentPosition });
                currentPosition++;
            });
            
            // Then, add selected Shopify media IDs with their positions
            // Use REST API numeric ID for backend comparison (the ID that matches Shopify's REST API)
            console.log(`üì¶ About to send ${selectedShopifyMedia.length} Shopify media items:`, selectedShopifyMedia);
            selectedShopifyMedia.forEach((media, index) => {
                // Use rest_api_id if available, otherwise fall back to id (REST API numeric ID)
                // The backend compares against the REST API numeric ID, not the global ID
                const restApiId = media.rest_api_id || media.id;
                const mediaIdForBackend = String(restApiId);  // Ensure it's a string for backend comparison
                console.log(`üì§ Appending media ID ${index + 1}/${selectedShopifyMedia.length}: REST ID ${mediaIdForBackend} (also has global_id: ${media.global_id})`);
                formData.append('shopify_media_ids', mediaIdForBackend);
                mediaOrder.push({ type: 'shopify', id: mediaIdForBackend, position: currentPosition });
                currentPosition++;
            });
            
            // Send the complete ordered list as JSON
            formData.append('media_order', JSON.stringify(mediaOrder));
            formData.append('media_count', selectedMediaFiles.length + selectedShopifyMedia.length);
            
            console.log('üì¶ Media order being sent:', mediaOrder);
            console.log('üì¶ Total Shopify media IDs being sent:', selectedShopifyMedia.length);
            const shopifyIdsBeingSent = selectedShopifyMedia.map(m => {
                const restId = m.rest_api_id || m.id;
                return { rest_api_id: restId, global_id: m.global_id, id: m.id };
            });
            console.log('üì¶ Shopify media IDs list (for removal check):', shopifyIdsBeingSent);
            
            // Also log what will be in shopify_media_ids (the keep list)
            const keepListIds = selectedShopifyMedia.map(m => String(m.rest_api_id || m.id));
            console.log('üì¶ shopify_media_ids (keep list) being sent to backend:', keepListIds);
        }

        // Handle dynamic colour inputs
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('add-colour-btn')) {
                e.preventDefault();
                const container = document.getElementById('colour-inputs-container');
                
                // Count existing cells (not counting the + button)
                const existingCells = container.querySelectorAll('.colour-cell');
                const index = existingCells.length;
                
                // Create new colour cell
                const newCell = document.createElement('div');
                newCell.className = 'colour-cell';
                newCell.style.cssText = 'display: flex; width: calc(25% - 6px); border: 1px solid #ddd; border-radius: 4px; overflow: hidden;';
                
                newCell.innerHTML = `
                    <input type="text" class="colour-name-input form-input" placeholder="Colour" data-index="${index}" data-part="name" style="border: none; border-right: 1px solid #ddd; width: 55%; flex-shrink: 0;">
                    <input type="text" class="colour-code-input form-input" placeholder="Code" data-index="${index}" data-part="code" style="border: none; border-right: 1px solid #ddd; width: 25%; flex-shrink: 0;">
                    <button type="button" class="colour-image-btn" data-index="${index}" style="background: none; border: none; width: 20%; height: 100%; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; flex-shrink: 0; min-height: 30px;" title="Select image for this colour">üñºÔ∏è</button>
                `;
                
                // Insert before the + button
                const plusButton = container.querySelector('.add-colour-btn');
                container.insertBefore(newCell, plusButton);
            } else if (e.target.id === 'fill-foil-colours-btn' || e.target.closest('#fill-foil-colours-btn')) {
                e.preventDefault();
                fillAllFoilColours();
            } else if (e.target.id === 'reset-colours-btn' || e.target.closest('#reset-colours-btn')) {
                e.preventDefault();
                resetColourOptions();
            }
        });
        
        // Function to reset all colour options
        function resetColourOptions() {
            const container = document.getElementById('colour-inputs-container');
            
            // Remove existing + button if it exists
            const existingPlusButton = container.querySelector('.add-colour-btn');
            if (existingPlusButton) {
                existingPlusButton.remove();
            }
            
            // Clear all existing colour cells
            const existingCells = container.querySelectorAll('.colour-cell');
            existingCells.forEach(cell => cell.remove());
            
            // Clear colour image mappings
            colourImageMap = {};
            colourImagePreview = {};
            
            // Create 2 empty colour cells (initial state)
            for (let index = 0; index < 2; index++) {
                const cell = document.createElement('div');
                cell.className = 'colour-cell';
                cell.style.cssText = 'display: flex; width: calc(25% - 6px); border: 1px solid #ddd; border-radius: 4px; overflow: hidden;';
                
                cell.innerHTML = `
                    <input type="text" class="colour-name-input form-input" placeholder="Colour" data-index="${index}" data-part="name" style="border: none; border-right: 1px solid #ddd; width: 55%; flex-shrink: 0;">
                    <input type="text" class="colour-code-input form-input" placeholder="Code" data-index="${index}" data-part="code" style="border: none; border-right: 1px solid #ddd; width: 25%; flex-shrink: 0;">
                    <button type="button" class="colour-image-btn" data-index="${index}" style="background: none; border: none; width: 20%; height: 100%; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; flex-shrink: 0; min-height: 30px;" title="Select image for this colour">üñºÔ∏è</button>
                `;
                
                container.appendChild(cell);
            }
            
            // Add the + button at the end
            const newPlusButton = document.createElement('button');
            newPlusButton.type = 'button';
            newPlusButton.className = 'add-colour-btn';
            newPlusButton.textContent = '+';
            newPlusButton.style.cssText = 'padding: 8px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;';
            container.appendChild(newPlusButton);
            
            console.log('‚úÖ Reset colour options to initial state');
        }
        
        // Handle backspace key to delete empty colour cells
        document.addEventListener('keydown', function(e) {
            // Check if the key is backspace and the target is a colour input
            if (e.key === 'Backspace' || e.key === 'Delete') {
                const target = e.target;
                if (target.classList.contains('colour-name-input') || target.classList.contains('colour-code-input')) {
                    const colourCell = target.closest('.colour-cell');
                    if (!colourCell) return;
                    
                    const nameInput = colourCell.querySelector('.colour-name-input');
                    const codeInput = colourCell.querySelector('.colour-code-input');
                    
                    // Check if both inputs are empty
                    const nameValue = nameInput.value.trim();
                    const codeValue = codeInput.value.trim();
                    
                    // If both inputs are empty and user presses backspace, delete the cell
                    // This allows deleting empty cells by backspacing when already blank
                    if (nameValue === '' && codeValue === '') {
                        // Check how many cells exist
                        const container = document.getElementById('colour-inputs-container');
                        const allCells = container.querySelectorAll('.colour-cell');
                        
                        // Only delete if there are more than 2 cells (keep at least 2)
                        if (allCells.length > 2) {
                            e.preventDefault();
                            
                            // Get the deleted index before removing
                            const deletedIndex = Array.from(allCells).indexOf(colourCell);
                            
                            // Remove the cell
                            colourCell.remove();
                            
                            // Clean up colour image maps for deleted index
                            delete colourImageMap[deletedIndex];
                            delete colourImagePreview[deletedIndex];
                            
                            // Re-index all remaining cells and shift image maps
                            const remainingCells = container.querySelectorAll('.colour-cell');
                            remainingCells.forEach((cell, newIndex) => {
                                const nameInp = cell.querySelector('.colour-name-input');
                                const codeInp = cell.querySelector('.colour-code-input');
                                const imgBtn = cell.querySelector('.colour-image-btn');
                                
                                if (nameInp) {
                                    nameInp.setAttribute('data-index', newIndex);
                                }
                                if (codeInp) {
                                    codeInp.setAttribute('data-index', newIndex);
                                }
                                if (imgBtn) {
                                    imgBtn.setAttribute('data-index', newIndex);
                                }
                                
                                // Shift image maps for cells after the deleted index
                                const oldIndex = newIndex >= deletedIndex ? newIndex + 1 : newIndex;
                                if (oldIndex !== newIndex) {
                                    if (colourImageMap[oldIndex] !== undefined) {
                                        colourImageMap[newIndex] = colourImageMap[oldIndex];
                                        delete colourImageMap[oldIndex];
                                    }
                                    if (colourImagePreview[oldIndex] !== undefined) {
                                        colourImagePreview[newIndex] = colourImagePreview[oldIndex];
                                        delete colourImagePreview[oldIndex];
                                    }
                                }
                            });
                            
                            console.log(`üóëÔ∏è Deleted empty colour cell at index ${deletedIndex}, ${remainingCells.length} cells remaining`);
                            
                            // Focus on the previous cell's code input, or next cell's name input if deleted was first
                            if (deletedIndex > 0 && remainingCells.length > 0) {
                                const prevCell = remainingCells[Math.min(deletedIndex - 1, remainingCells.length - 1)];
                                const prevCodeInput = prevCell.querySelector('.colour-code-input');
                                if (prevCodeInput) {
                                    prevCodeInput.focus();
                                }
                            } else if (remainingCells.length > 0) {
                                const nextCell = remainingCells[0];
                                const nextNameInput = nextCell.querySelector('.colour-name-input');
                                if (nextNameInput) {
                                    nextNameInput.focus();
                                }
                            }
                        }
                    }
                }
            }
        });
        
        // Function to fill all foil colours
        async function fillAllFoilColours() {
            try {
                console.log('üîÑ Fetching foil colours from API...');
                const response = await fetch('/api/foil-colours');
                if (!response.ok) {
                    throw new Error(`Failed to fetch foil colours: ${response.status}`);
                }
                const data = await response.json();
                
                if (!data.success || !data.colours) {
                    throw new Error('Invalid response from foil colours API');
                }
                
                console.log(`‚úÖ Received ${data.colours.length} foil colours:`, data.colours);
                
                const container = document.getElementById('colour-inputs-container');
                
                // Remove existing + button if it exists (we'll add it back at the end)
                const existingPlusButton = container.querySelector('.add-colour-btn');
                if (existingPlusButton) {
                    existingPlusButton.remove();
                }
                
                // Clear all existing colour cells
                const existingCells = container.querySelectorAll('.colour-cell');
                existingCells.forEach(cell => cell.remove());
                
                // Create colour cells for each foil colour
                data.colours.forEach((colourTuple, index) => {
                    const [name, code] = colourTuple;
                    
                    const cell = document.createElement('div');
                    cell.className = 'colour-cell';
                    cell.style.cssText = 'display: flex; width: calc(25% - 6px); border: 1px solid #ddd; border-radius: 4px; overflow: hidden;';
                    
                    cell.innerHTML = `
                        <input type="text" class="colour-name-input form-input" placeholder="Colour" data-index="${index}" data-part="name" value="${name}" style="border: none; border-right: 1px solid #ddd; width: 55%; flex-shrink: 0;">
                        <input type="text" class="colour-code-input form-input" placeholder="Code" data-index="${index}" data-part="code" value="${code}" style="border: none; border-right: 1px solid #ddd; width: 25%; flex-shrink: 0;">
                        <button type="button" class="colour-image-btn" data-index="${index}" style="background: none; border: none; width: 20%; height: 100%; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; flex-shrink: 0; min-height: 30px;" title="Select image for this colour">üñºÔ∏è</button>
                    `;
                    
                    container.appendChild(cell);
                });
                
                // Add the + button at the end
                const newPlusButton = document.createElement('button');
                newPlusButton.type = 'button';
                newPlusButton.className = 'add-colour-btn';
                newPlusButton.textContent = '+';
                newPlusButton.style.cssText = 'padding: 8px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;';
                container.appendChild(newPlusButton);
                
                console.log(`‚úÖ Filled ${data.colours.length} foil colours into colour inputs`);
            } catch (error) {
                console.error('‚ùå Error filling foil colours:', error);
                alert(`Failed to load foil colours: ${error.message}`);
            }
        }

        // Function to load colours into the inputs (called when loading a product for editing)
        function loadColoursIntoInputs(coloursStr) {
            const container = document.getElementById('colour-inputs-container');
            container.innerHTML = '';
            
            let colours = [];
            if (coloursStr && coloursStr.trim() !== '') {
                colours = coloursStr.split(',').map(c => c.trim()).filter(c => c.length > 0);
            }
            
            // If no colours, start with 2 empty cells
            if (colours.length === 0) {
                colours.push(':', ':');
            }
            
            // Create cells for each colour
            colours.forEach((colour, index) => {
                let name = '', code = '';
                if (colour.includes(':')) {
                    const parts = colour.split(':', 2);
                    name = parts[0].trim();
                    code = parts[1] ? parts[1].trim() : '';
                } else {
                    name = colour;
                }
                
                const cell = document.createElement('div');
                cell.className = 'colour-cell';
                cell.style.cssText = 'display: flex; width: calc(25% - 6px); border: 1px solid #ddd; border-radius: 4px; overflow: hidden;';
                
                cell.innerHTML = `
                    <input type="text" class="colour-name-input form-input" placeholder="Colour" data-index="${index}" data-part="name" value="${name}" style="border: none; border-right: 1px solid #ddd; width: 55%; flex-shrink: 0;">
                    <input type="text" class="colour-code-input form-input" placeholder="Code" data-index="${index}" data-part="code" value="${code}" style="border: none; border-right: 1px solid #ddd; width: 25%; flex-shrink: 0;">
                    <button type="button" class="colour-image-btn" data-index="${index}" style="background: none; border: none; width: 20%; height: 100%; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; flex-shrink: 0; min-height: 30px;" title="Select image for this colour">üñºÔ∏è</button>
                `;
                
                container.appendChild(cell);
            });
            
            // Add the + button at the end
            const plusButton = document.createElement('button');
            plusButton.type = 'button';
            plusButton.className = 'add-colour-btn';
            plusButton.textContent = '+';
            plusButton.style.cssText = 'padding: 8px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;';
            container.appendChild(plusButton);
        }

        // Handle colour image selection
        let colourImageMap = {}; // Store mapping of colour index to media index in selectedShopifyMedia
        let colourImagePreview = {}; // Store mapping of colour index to image URL for preview
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('colour-image-btn') || e.target.parentElement?.classList.contains('colour-image-btn')) {
                const btn = e.target.classList.contains('colour-image-btn') ? e.target : e.target.parentElement;
                const colourIndex = btn.getAttribute('data-index');
                const colourCell = btn.closest('.colour-cell');
                const colourNameInput = colourCell?.querySelector('.colour-name-input');
                const colourName = colourNameInput?.value || '';
                
                // Get all available media (both selectedShopifyMedia and selectedMediaFiles)
                const shopifyMedia = selectedShopifyMedia || [];
                const newMediaFiles = selectedMediaFiles || [];
                const allMediaItems = [...shopifyMedia, ...newMediaFiles];
                
                if (allMediaItems.length === 0) {
                    alert('No images available. Please upload images first.');
                    return;
                }
                
                // Create popup to select image
                const popup = document.createElement('div');
                popup.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 10000; max-width: 600px; max-height: 70vh; overflow-y: auto;';
                popup.innerHTML = `
                    <h3 style="margin-top: 0;">Select image for "${colourName || 'Colour ' + colourIndex}"</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; margin-top: 15px;">
                        ${allMediaItems.map((media, idx) => {
                            // Handle both selectedShopifyMedia (has url property) and selectedMediaFiles (has File object)
                            let imageUrl = '';
                            if (media.url) {
                                // Shopify media
                                imageUrl = media.url;
                            } else if (media instanceof File) {
                                // New file being uploaded
                                imageUrl = URL.createObjectURL(media);
                            } else if (media.src) {
                                // Fallback
                                imageUrl = media.src;
                            }
                            return `
                            <div style="cursor: pointer; border: 2px solid #ddd; border-radius: 4px; overflow: hidden;" onclick="selectColourImage(${idx}, ${colourIndex})">
                                <img src="${imageUrl}" style="width: 100%; height: 100px; object-fit: cover;" onerror="this.style.background='#f0f0f0'; this.innerHTML='‚ùå'">
                            </div>
                        `;
                        }).join('')}
                    </div>
                    <button onclick="this.closest('div').remove()" style="margin-top: 15px; padding: 8px 15px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                `;
                document.body.appendChild(popup);
            }
        });
        
        // Function to select image for a colour
        window.selectColourImage = function(mediaIndex, colourIndex) {
            // Get media from combined array (shopifyMedia + newMediaFiles)
            const shopifyMedia = selectedShopifyMedia || [];
            const newMediaFiles = selectedMediaFiles || [];
            const allMediaItems = [...shopifyMedia, ...newMediaFiles];
            
            const media = allMediaItems[mediaIndex];
            if (!media) return;
            
            // Store the media index and preview URL
            colourImageMap[colourIndex] = mediaIndex;
            
            // Get preview URL
            let previewUrl = '';
            if (media.url) {
                previewUrl = media.url;
            } else if (media instanceof File) {
                previewUrl = URL.createObjectURL(media);
            } else if (media.src) {
                previewUrl = media.src;
            }
            colourImagePreview[colourIndex] = previewUrl;
            
            // Update the button to show the image preview
            const btn = document.querySelector(`.colour-image-btn[data-index="${colourIndex}"]`);
            if (btn && colourImagePreview[colourIndex]) {
                btn.style.backgroundImage = `url(${colourImagePreview[colourIndex]})`;
                btn.style.backgroundSize = 'cover';
                btn.style.backgroundPosition = 'center';
                btn.style.backgroundRepeat = 'no-repeat';
                btn.innerHTML = '';
                btn.title = 'Click to change image';
            }
            
            // Close popup
            document.querySelectorAll('div[style*="position: fixed"]').forEach(p => p.remove());
        };

        // Hook into metafield loading to populate colour inputs when editing products
        // We'll save a reference to the original function and wrap it
        const originalDisplayMetafields_Inner = displayMetafields;
        displayMetafields = function(metafields) {
            // Call the original function
            originalDisplayMetafields_Inner(metafields);
            
            // Check if product_colours metafield exists and load it
            const coloursMetafield = metafields.find(m => m.key === 'product_colours' && m.namespace === 'custom');
            if (coloursMetafield && coloursMetafield.value) {
                loadColoursIntoInputs(coloursMetafield.value);
            } else if (coloursMetafield) {
                // Metafield exists but is empty, start with 2 empty inputs
                loadColoursIntoInputs('');
            }
        };

        // Initialize colour inputs when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadColoursIntoInputs('');
        });
    </script>
</body>
</html>
